/**
 * 
 * WARNING! This file was autogenerated by: 
 *  _   _ _   _ __   __ 
 * | | | | | | |\ \ / / 
 * | | | | |_| | \ V /  
 * | | | |  _  | /   \  
 * | |_| | | | |/ /^\ \ 
 *  \___/\_| |_/\/   \/ 
 * 
 * This file was autogenerated by UnrealHxGenerator using UHT definitions.
 * It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!
 * In order to add more definitions, create or edit a type with the same name/package, but with an `_Extra` suffix
**/
package unreal;

@:glueCppIncludes("Kismet/KismetMathLibrary.h")
@:uextern @:uclass extern class UKismetMathLibrary extends unreal.UBlueprintFunctionLibrary {
  
  /**
    Returns a uniformly distributed random bool
  **/
  @:ufunction(BlueprintCallable) static public function RandomBool() : Bool;
  
  /**
    Get a random chance with the specified weight. Range of weight is 0.0 - 1.0 E.g.,
                 Weight = .6 return value = True 60% of the time
  **/
  @:ufunction(BlueprintCallable) static public function RandomBoolWithWeight(@:bpopt("0.5") Weight : unreal.Float32) : Bool;
  
  /**
    Get a random chance with the specified weight. Range of weight is 0.0 - 1.0 E.g.,
                  Weight = .6 return value = True 60% of the time
  **/
  @:ufunction(BlueprintCallable) static public function RandomBoolWithWeightFromStream(@:bpopt("0.5") Weight : unreal.Float32, RandomStream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : Bool;
  
  /**
    Returns the logical complement of the Boolean value (NOT A)
  **/
  @:ufunction(BlueprintCallable) static public function Not_PreBool(A : Bool) : Bool;
  
  /**
    Returns true if the values are equal (A == B)
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_BoolBool(A : Bool, B : Bool) : Bool;
  
  /**
    Returns true if the values are not equal (A != B)
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_BoolBool(A : Bool, B : Bool) : Bool;
  
  /**
    Returns the logical AND of two values (A AND B)
  **/
  @:ufunction(BlueprintCallable) static public function BooleanAND(A : Bool, B : Bool) : Bool;
  
  /**
    Returns the logical NAND of two values (A AND B)
  **/
  @:ufunction(BlueprintCallable) static public function BooleanNAND(A : Bool, B : Bool) : Bool;
  
  /**
    Returns the logical OR of two values (A OR B)
  **/
  @:ufunction(BlueprintCallable) static public function BooleanOR(A : Bool, B : Bool) : Bool;
  
  /**
    Returns the logical eXclusive OR of two values (A XOR B)
  **/
  @:ufunction(BlueprintCallable) static public function BooleanXOR(A : Bool, B : Bool) : Bool;
  
  /**
    Returns the logical Not OR of two values (A NOR B)
  **/
  @:ufunction(BlueprintCallable) static public function BooleanNOR(A : Bool, B : Bool) : Bool;
  
  /**
    Multiplication (A * B)
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : unreal.UInt8;
  
  /**
    Division (A / B)
  **/
  @:ufunction(BlueprintCallable) static public function Divide_ByteByte(A : unreal.UInt8, B : unreal.UInt8 = 1) : unreal.UInt8;
  
  /**
    Modulo (A % B)
  **/
  @:ufunction(BlueprintCallable) static public function Percent_ByteByte(A : unreal.UInt8, B : unreal.UInt8 = 1) : unreal.UInt8;
  
  /**
    Addition (A + B)
  **/
  @:ufunction(BlueprintCallable) static public function Add_ByteByte(A : unreal.UInt8, B : unreal.UInt8 = 1) : unreal.UInt8;
  
  /**
    Subtraction (A - B)
  **/
  @:ufunction(BlueprintCallable) static public function Subtract_ByteByte(A : unreal.UInt8, B : unreal.UInt8 = 1) : unreal.UInt8;
  
  /**
    Returns the minimum value of A and B
  **/
  @:ufunction(BlueprintCallable) static public function BMin(A : unreal.UInt8, B : unreal.UInt8) : unreal.UInt8;
  
  /**
    Returns the maximum value of A and B
  **/
  @:ufunction(BlueprintCallable) static public function BMax(A : unreal.UInt8, B : unreal.UInt8) : unreal.UInt8;
  
  /**
    Returns true if A is less than B (A < B)
  **/
  @:ufunction(BlueprintCallable) static public function Less_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : Bool;
  
  /**
    Returns true if A is greater than B (A > B)
  **/
  @:ufunction(BlueprintCallable) static public function Greater_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : Bool;
  
  /**
    Returns true if A is less than or equal to B (A <= B)
  **/
  @:ufunction(BlueprintCallable) static public function LessEqual_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : Bool;
  
  /**
    Returns true if A is greater than or equal to B (A >= B)
  **/
  @:ufunction(BlueprintCallable) static public function GreaterEqual_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : Bool;
  
  /**
    Returns true if A is equal to B (A == B)
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : Bool;
  
  /**
    Returns true if A is not equal to B (A != B)
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_ByteByte(A : unreal.UInt8, B : unreal.UInt8) : Bool;
  
  /**
    Multiplication (A * B)
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_IntInt(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Division (A / B)
  **/
  @:ufunction(BlueprintCallable) static public function Divide_IntInt(A : unreal.Int32, B : unreal.Int32 = 1) : unreal.Int32;
  
  /**
    Modulo (A % B)
  **/
  @:ufunction(BlueprintCallable) static public function Percent_IntInt(A : unreal.Int32, B : unreal.Int32 = 1) : unreal.Int32;
  
  /**
    Addition (A + B)
  **/
  @:ufunction(BlueprintCallable) static public function Add_IntInt(A : unreal.Int32, B : unreal.Int32 = 1) : unreal.Int32;
  
  /**
    Subtraction (A - B)
  **/
  @:ufunction(BlueprintCallable) static public function Subtract_IntInt(A : unreal.Int32, B : unreal.Int32 = 1) : unreal.Int32;
  
  /**
    Returns true if A is less than B (A < B)
  **/
  @:ufunction(BlueprintCallable) static public function Less_IntInt(A : unreal.Int32, B : unreal.Int32) : Bool;
  
  /**
    Returns true if A is greater than B (A > B)
  **/
  @:ufunction(BlueprintCallable) static public function Greater_IntInt(A : unreal.Int32, B : unreal.Int32) : Bool;
  
  /**
    Returns true if A is less than or equal to B (A <= B)
  **/
  @:ufunction(BlueprintCallable) static public function LessEqual_IntInt(A : unreal.Int32, B : unreal.Int32) : Bool;
  
  /**
    Returns true if A is greater than or equal to B (A >= B)
  **/
  @:ufunction(BlueprintCallable) static public function GreaterEqual_IntInt(A : unreal.Int32, B : unreal.Int32) : Bool;
  
  /**
    Returns true if A is equal to B (A == B)
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_IntInt(A : unreal.Int32, B : unreal.Int32) : Bool;
  
  /**
    Returns true if A is not equal to B (A != B)
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_IntInt(A : unreal.Int32, B : unreal.Int32) : Bool;
  
  /**
    Returns true if value is between Min and Max (V >= Min && V <= Max)
    If InclusiveMin is true, value needs to be equal or larger than Min, else it needs to be larger
    If InclusiveMax is true, value needs to be smaller or equal than Max, else it needs to be smaller
  **/
  @:ufunction(BlueprintCallable) static public function InRange_IntInt(Value : unreal.Int32, @:bpopt("0") Min : unreal.Int32, @:bpopt("10") Max : unreal.Int32, InclusiveMin : Bool = true, InclusiveMax : Bool = true) : Bool;
  
  /**
    Bitwise AND (A & B)
  **/
  @:ufunction(BlueprintCallable) static public function And_IntInt(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Bitwise XOR (A ^ B)
  **/
  @:ufunction(BlueprintCallable) static public function Xor_IntInt(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Bitwise OR (A | B)
  **/
  @:ufunction(BlueprintCallable) static public function Or_IntInt(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Bitwise NOT (~A)
  **/
  @:ufunction(BlueprintCallable) static public function Not_Int(A : unreal.Int32) : unreal.Int32;
  
  /**
    Sign (integer, returns -1 if A < 0, 0 if A is zero, and +1 if A > 0)
  **/
  @:ufunction(BlueprintCallable) static public function SignOfInteger(A : unreal.Int32) : unreal.Int32;
  
  /**
    Returns a uniformly distributed random number between 0 and Max - 1
  **/
  @:ufunction(BlueprintCallable) static public function RandomInteger(Max : unreal.Int32) : unreal.Int32;
  
  /**
    Return a random integer between Min and Max (>= Min and <= Max)
  **/
  @:ufunction(BlueprintCallable) static public function RandomIntegerInRange(Min : unreal.Int32, Max : unreal.Int32) : unreal.Int32;
  
  /**
    Returns the minimum value of A and B
  **/
  @:ufunction(BlueprintCallable) static public function Min(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Returns the maximum value of A and B
  **/
  @:ufunction(BlueprintCallable) static public function Max(A : unreal.Int32, B : unreal.Int32) : unreal.Int32;
  
  /**
    Returns Value clamped to be between A and B (inclusive)
  **/
  @:ufunction(BlueprintCallable) static public function Clamp(Value : unreal.Int32, Min : unreal.Int32, Max : unreal.Int32) : unreal.Int32;
  
  /**
    Returns the absolute (positive) value of A
  **/
  @:ufunction(BlueprintCallable) static public function Abs_Int(A : unreal.Int32) : unreal.Int32;
  
  /**
    Multiplication (A * B)
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_Int64Int64(A : unreal.Int64, B : unreal.Int64) : unreal.Int64;
  
  /**
    Division (A / B)
  **/
  @:ufunction(BlueprintCallable) static public function Divide_Int64Int64(A : unreal.Int64, B : unreal.Int64 = 1) : unreal.Int64;
  
  /**
    Addition (A + B)
  **/
  @:ufunction(BlueprintCallable) static public function Add_Int64Int64(A : unreal.Int64, B : unreal.Int64 = 1) : unreal.Int64;
  
  /**
    Subtraction (A - B)
  **/
  @:ufunction(BlueprintCallable) static public function Subtract_Int64Int64(A : unreal.Int64, B : unreal.Int64 = 1) : unreal.Int64;
  
  /**
    Returns true if A is less than B (A < B)
  **/
  @:ufunction(BlueprintCallable) static public function Less_Int64Int64(A : unreal.Int64, B : unreal.Int64) : Bool;
  
  /**
    Returns true if A is greater than B (A > B)
  **/
  @:ufunction(BlueprintCallable) static public function Greater_Int64Int64(A : unreal.Int64, B : unreal.Int64) : Bool;
  
  /**
    Returns true if A is less than or equal to B (A <= B)
  **/
  @:ufunction(BlueprintCallable) static public function LessEqual_Int64Int64(A : unreal.Int64, B : unreal.Int64) : Bool;
  
  /**
    Returns true if A is greater than or equal to B (A >= B)
  **/
  @:ufunction(BlueprintCallable) static public function GreaterEqual_Int64Int64(A : unreal.Int64, B : unreal.Int64) : Bool;
  
  /**
    Returns true if A is equal to B (A == B)
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_Int64Int64(A : unreal.Int64, B : unreal.Int64) : Bool;
  
  /**
    Returns true if A is not equal to B (A != B)
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_Int64Int64(A : unreal.Int64, B : unreal.Int64) : Bool;
  
  /**
    Returns true if value is between Min and Max (V >= Min && V <= Max)
    If InclusiveMin is true, value needs to be equal or larger than Min, else it needs to be larger
    If InclusiveMax is true, value needs to be smaller or equal than Max, else it needs to be smaller
  **/
  @:ufunction(BlueprintCallable) static public function InRange_Int64Int64(Value : unreal.Int64, @:bpopt("0") Min : unreal.Int64, @:bpopt("10") Max : unreal.Int64, InclusiveMin : Bool = true, InclusiveMax : Bool = true) : Bool;
  
  /**
    Bitwise AND (A & B)
  **/
  @:ufunction(BlueprintCallable) static public function And_Int64Int64(A : unreal.Int64, B : unreal.Int64) : unreal.Int64;
  
  /**
    Bitwise XOR (A ^ B)
  **/
  @:ufunction(BlueprintCallable) static public function Xor_Int64Int64(A : unreal.Int64, B : unreal.Int64) : unreal.Int64;
  
  /**
    Bitwise OR (A | B)
  **/
  @:ufunction(BlueprintCallable) static public function Or_Int64Int64(A : unreal.Int64, B : unreal.Int64) : unreal.Int64;
  
  /**
    Bitwise NOT (~A)
  **/
  @:ufunction(BlueprintCallable) static public function Not_Int64(A : unreal.Int64) : unreal.Int64;
  
  /**
    Sign (integer64, returns -1 if A < 0, 0 if A is zero, and +1 if A > 0)
  **/
  @:ufunction(BlueprintCallable) static public function SignOfInteger64(A : unreal.Int64) : unreal.Int64;
  
  /**
    Returns a uniformly distributed random number between 0 and Max - 1
  **/
  @:ufunction(BlueprintCallable) static public function RandomInteger64(Max : unreal.Int64) : unreal.Int64;
  
  /**
    Return a random integer64 between Min and Max (>= Min and <= Max)
  **/
  @:ufunction(BlueprintCallable) static public function RandomInteger64InRange(Min : unreal.Int64, Max : unreal.Int64) : unreal.Int64;
  
  /**
    Returns the minimum value of A and B
  **/
  @:ufunction(BlueprintCallable) static public function MinInt64(A : unreal.Int64, B : unreal.Int64) : unreal.Int64;
  
  /**
    Returns the maximum value of A and B
  **/
  @:ufunction(BlueprintCallable) static public function MaxInt64(A : unreal.Int64, B : unreal.Int64) : unreal.Int64;
  
  /**
    Returns Value clamped to be between A and B (inclusive)
  **/
  @:ufunction(BlueprintCallable) static public function ClampInt64(Value : unreal.Int64, Min : unreal.Int64, Max : unreal.Int64) : unreal.Int64;
  
  /**
    Returns the absolute (positive) value of A
  **/
  @:ufunction(BlueprintCallable) static public function Abs_Int64(A : unreal.Int64) : unreal.Int64;
  
  /**
    Power (Base to the Exp-th power)
  **/
  @:ufunction(BlueprintCallable) static public function MultiplyMultiply_FloatFloat(Base : unreal.Float32, Exp : unreal.Float32) : unreal.Float32;
  
  /**
    Multiplication (A * B)
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_FloatFloat(A : unreal.Float32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Multiplication (A * B)
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_IntFloat(A : unreal.Int32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Division (A / B)
  **/
  @:ufunction(BlueprintCallable) static public function Divide_FloatFloat(A : unreal.Float32, B : unreal.Float32 = 1.000000) : unreal.Float32;
  
  /**
    Modulo (A % B)
  **/
  @:ufunction(BlueprintCallable) static public function Percent_FloatFloat(A : unreal.Float32, B : unreal.Float32 = 1.000000) : unreal.Float32;
  
  /**
    Returns the fractional part of a float.
  **/
  @:ufunction(BlueprintCallable) static public function Fraction(A : unreal.Float32) : unreal.Float32;
  
  /**
    Addition (A + B)
  **/
  @:ufunction(BlueprintCallable) static public function Add_FloatFloat(A : unreal.Float32, B : unreal.Float32 = 1.000000) : unreal.Float32;
  
  /**
    Subtraction (A - B)
  **/
  @:ufunction(BlueprintCallable) static public function Subtract_FloatFloat(A : unreal.Float32, B : unreal.Float32 = 1.000000) : unreal.Float32;
  
  /**
    Returns true if A is Less than B (A < B)
  **/
  @:ufunction(BlueprintCallable) static public function Less_FloatFloat(A : unreal.Float32, B : unreal.Float32) : Bool;
  
  /**
    Returns true if A is greater than B (A > B)
  **/
  @:ufunction(BlueprintCallable) static public function Greater_FloatFloat(A : unreal.Float32, B : unreal.Float32) : Bool;
  
  /**
    Returns true if A is Less than or equal to B (A <= B)
  **/
  @:ufunction(BlueprintCallable) static public function LessEqual_FloatFloat(A : unreal.Float32, B : unreal.Float32) : Bool;
  
  /**
    Returns true if A is greater than or equal to B (A >= B)
  **/
  @:ufunction(BlueprintCallable) static public function GreaterEqual_FloatFloat(A : unreal.Float32, B : unreal.Float32) : Bool;
  
  /**
    Returns true if A is exactly equal to B (A == B)
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_FloatFloat(A : unreal.Float32, B : unreal.Float32) : Bool;
  
  /**
    Returns true if A is nearly equal to B (|A - B| < ErrorTolerance)
  **/
  @:ufunction(BlueprintCallable) static public function NearlyEqual_FloatFloat(A : unreal.Float32, B : unreal.Float32, ErrorTolerance : unreal.Float32 = 0.000001) : Bool;
  
  /**
    Returns true if A does not equal B (A != B)
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_FloatFloat(A : unreal.Float32, B : unreal.Float32) : Bool;
  
  /**
    Returns true if value is between Min and Max (V >= Min && V <= Max)
    If InclusiveMin is true, value needs to be equal or larger than Min, else it needs to be larger
    If InclusiveMax is true, value needs to be smaller or equal than Max, else it needs to be smaller
  **/
  @:ufunction(BlueprintCallable) static public function InRange_FloatFloat(Value : unreal.Float32, @:bpopt("0.0") Min : unreal.Float32, @:bpopt("1.0") Max : unreal.Float32, InclusiveMin : Bool = true, InclusiveMax : Bool = true) : Bool;
  
  /**
    Returns the hypotenuse of a right-angled triangle given the width and height.
  **/
  @:ufunction(BlueprintCallable) static public function Hypotenuse(Width : unreal.Float32, Height : unreal.Float32) : unreal.Float32;
  
  /**
    Snaps a value to the nearest grid multiple. E.g.,
                Location = 5.1, GridSize = 10.0 : return value = 10.0
    If GridSize is 0 Location is returned
    if GridSize is very small precision issues may occur.
  **/
  @:ufunction(BlueprintCallable) static public function GridSnap_Float(Location : unreal.Float32, GridSize : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the absolute (positive) value of A
  **/
  @:ufunction(BlueprintCallable) static public function Abs(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the sine of A (expects Radians)
  **/
  @:ufunction(BlueprintCallable) static public function Sin(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse sine (arcsin) of A (result is in Radians)
  **/
  @:ufunction(BlueprintCallable) static public function Asin(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the cosine of A (expects Radians)
  **/
  @:ufunction(BlueprintCallable) static public function Cos(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse cosine (arccos) of A (result is in Radians)
  **/
  @:ufunction(BlueprintCallable) static public function Acos(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the tan of A (expects Radians)
  **/
  @:ufunction(BlueprintCallable) static public function Tan(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse tan (atan) (result is in Radians)
  **/
  @:ufunction(BlueprintCallable) static public function Atan(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse tan (atan2) of A/B (result is in Radians)
  **/
  @:ufunction(BlueprintCallable) static public function Atan2(A : unreal.Float32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Returns exponential(e) to the power A (e^A)
  **/
  @:ufunction(BlueprintCallable) static public function Exp(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns log of A base B (if B^R == A, returns R)
  **/
  @:ufunction(BlueprintCallable) static public function Log(A : unreal.Float32, Base : unreal.Float32 = 1.000000) : unreal.Float32;
  
  /**
    Returns natural log of A (if e^R == A, returns R)
  **/
  @:ufunction(BlueprintCallable) static public function Loge(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns square root of A
  **/
  @:ufunction(BlueprintCallable) static public function Sqrt(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns square of A (A*A)
  **/
  @:ufunction(BlueprintCallable) static public function Square(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns a random float between 0 and 1
  **/
  @:ufunction(BlueprintCallable) static public function RandomFloat() : unreal.Float32;
  
  /**
    Generate a random number between Min and Max
  **/
  @:ufunction(BlueprintCallable) static public function RandomFloatInRange(Min : unreal.Float32, Max : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the value of PI
  **/
  @:ufunction(BlueprintCallable) static public function GetPI() : unreal.Float32;
  
  /**
    Returns the value of TAU (= 2 * PI)
  **/
  @:ufunction(BlueprintCallable) static public function GetTAU() : unreal.Float32;
  
  /**
    Returns radians value based on the input degrees
  **/
  @:ufunction(BlueprintCallable) static public function DegreesToRadians(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns degrees value based on the input radians
  **/
  @:ufunction(BlueprintCallable) static public function RadiansToDegrees(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the sin of A (expects Degrees)
  **/
  @:ufunction(BlueprintCallable) static public function DegSin(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse sin (arcsin) of A (result is in Degrees)
  **/
  @:ufunction(BlueprintCallable) static public function DegAsin(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the cos of A (expects Degrees)
  **/
  @:ufunction(BlueprintCallable) static public function DegCos(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse cos (arccos) of A (result is in Degrees)
  **/
  @:ufunction(BlueprintCallable) static public function DegAcos(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the tan of A (expects Degrees)
  **/
  @:ufunction(BlueprintCallable) static public function DegTan(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse tan (atan) (result is in Degrees)
  **/
  @:ufunction(BlueprintCallable) static public function DegAtan(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the inverse tan (atan2) of A/B (result is in Degrees)
  **/
  @:ufunction(BlueprintCallable) static public function DegAtan2(A : unreal.Float32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Clamps an arbitrary angle to be between the given angles.  Will clamp to nearest boundary.
    
    @param MinAngleDegrees       "from" angle that defines the beginning of the range of valid angles (sweeping clockwise)
    @param MaxAngleDegrees       "to" angle that defines the end of the range of valid angles
    @return Returns clamped angle in the range -180..180.
  **/
  @:ufunction(BlueprintCallable) static public function ClampAngle(AngleDegrees : unreal.Float32, MinAngleDegrees : unreal.Float32, MaxAngleDegrees : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the minimum value of A and B
  **/
  @:ufunction(BlueprintCallable) static public function FMin(A : unreal.Float32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Returns the maximum value of A and B
  **/
  @:ufunction(BlueprintCallable) static public function FMax(A : unreal.Float32, B : unreal.Float32) : unreal.Float32;
  
  /**
    Returns Value clamped between A and B (inclusive)
  **/
  @:ufunction(BlueprintCallable) static public function FClamp(Value : unreal.Float32, @:bpopt("0.0") Min : unreal.Float32, @:bpopt("1.0") Max : unreal.Float32) : unreal.Float32;
  
  /**
    Returns max of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.
  **/
  @:ufunction(BlueprintCallable) static public function MaxOfIntArray(IntArray : unreal.Const<unreal.PRef<unreal.TArray<unreal.Int32>>>, IndexOfMaxValue : unreal.Int32, MaxValue : unreal.Int32) : Void;
  
  /**
    Returns min of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.
  **/
  @:ufunction(BlueprintCallable) static public function MinOfIntArray(IntArray : unreal.Const<unreal.PRef<unreal.TArray<unreal.Int32>>>, IndexOfMinValue : unreal.Int32, MinValue : unreal.Int32) : Void;
  
  /**
    Returns max of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.
  **/
  @:ufunction(BlueprintCallable) static public function MaxOfFloatArray(FloatArray : unreal.Const<unreal.PRef<unreal.TArray<unreal.Float32>>>, IndexOfMaxValue : unreal.Int32, MaxValue : unreal.Float32) : Void;
  
  /**
    Returns min of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.
  **/
  @:ufunction(BlueprintCallable) static public function MinOfFloatArray(FloatArray : unreal.Const<unreal.PRef<unreal.TArray<unreal.Float32>>>, IndexOfMinValue : unreal.Int32, MinValue : unreal.Float32) : Void;
  
  /**
    Returns max of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.
  **/
  @:ufunction(BlueprintCallable) static public function MaxOfByteArray(ByteArray : unreal.Const<unreal.PRef<unreal.TArray<unreal.UInt8>>>, IndexOfMaxValue : unreal.Int32, MaxValue : unreal.UInt8) : Void;
  
  /**
    Returns min of all array entries and the index at which it was found. Returns value of 0 and index of -1 if the supplied array is empty.
  **/
  @:ufunction(BlueprintCallable) static public function MinOfByteArray(ByteArray : unreal.Const<unreal.PRef<unreal.TArray<unreal.UInt8>>>, IndexOfMinValue : unreal.Int32, MinValue : unreal.UInt8) : Void;
  
  /**
    Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)
  **/
  @:ufunction(BlueprintCallable) static public function Lerp(A : unreal.Float32, B : unreal.Float32, Alpha : unreal.Float32) : unreal.Float32;
  
  /**
    Easeing  between A and B using a specified easing function
  **/
  @:ufunction(BlueprintCallable) static public function Ease(A : unreal.Float32, B : unreal.Float32, Alpha : unreal.Float32, EasingFunc : unreal.EEasingFunc, BlendExp : unreal.Float32 = 2.000000, Steps : unreal.Int32 = 2) : unreal.Float32;
  
  /**
    Rounds A to the nearest integer
  **/
  @:ufunction(BlueprintCallable) static public function Round(A : unreal.Float32) : unreal.Int32;
  
  /**
    Rounds A to the largest previous integer
  **/
  @:ufunction(BlueprintCallable) static public function FFloor(A : unreal.Float32) : unreal.Int32;
  
  /**
    Rounds A to an integer with truncation towards zero.  (e.g. -1.7 truncated to -1, 2.8 truncated to 2)
  **/
  @:ufunction(BlueprintCallable) static public function FTrunc(A : unreal.Float32) : unreal.Int32;
  
  /**
    Rounds A to the nearest 32 bit integer then upconverts to 64 bit integer
  **/
  @:ufunction(BlueprintCallable) static public function Round64(A : unreal.Float32) : unreal.Int64;
  
  /**
    Rounds A to the largest previous 32 bit integer then upconverts to 64 bit integer
  **/
  @:ufunction(BlueprintCallable) static public function FFloor64(A : unreal.Float32) : unreal.Int64;
  
  /**
    Rounds A to an 32 bit integer with truncation towards zero then upconverts to 64 bit integer.  (e.g. -1.7 truncated to -1, 2.8 truncated to 2)
  **/
  @:ufunction(BlueprintCallable) static public function FTrunc64(A : unreal.Float32) : unreal.Int64;
  
  /**
    Rounds A to the smallest following 32 bit integer then upconverts to 64 bit integer
  **/
  @:ufunction(BlueprintCallable) static public function FCeil64(A : unreal.Float32) : unreal.Int64;
  
  /**
    Rounds A to the smallest following integer
  **/
  @:ufunction(BlueprintCallable) static public function FCeil(A : unreal.Float32) : unreal.Int32;
  
  /**
    Returns the number of times Divisor will go into Dividend (i.e., Dividend divided by Divisor), as well as the remainder
  **/
  @:ufunction(BlueprintCallable) static public function FMod(Dividend : unreal.Float32, Divisor : unreal.Float32, Remainder : unreal.Float32) : unreal.Int32;
  
  /**
    Sign (float, returns -1 if A < 0, 0 if A is zero, and +1 if A > 0)
  **/
  @:ufunction(BlueprintCallable) static public function SignOfFloat(A : unreal.Float32) : unreal.Float32;
  
  /**
    Returns Value normalized to the given range.  (e.g. 20 normalized to the range 10->50 would result in 0.25)
  **/
  @:ufunction(BlueprintCallable) static public function NormalizeToRange(Value : unreal.Float32, RangeMin : unreal.Float32, RangeMax : unreal.Float32) : unreal.Float32;
  
  /**
    Returns Value mapped from one range into another.  (e.g. 20 normalized from the range 10->50 to 20->40 would result in 25)
  **/
  @:ufunction(BlueprintCallable) static public function MapRangeUnclamped(Value : unreal.Float32, InRangeA : unreal.Float32, InRangeB : unreal.Float32, OutRangeA : unreal.Float32, OutRangeB : unreal.Float32) : unreal.Float32;
  
  /**
    Returns Value mapped from one range into another where the Value is clamped to the Input Range.  (e.g. 0.5 normalized from the range 0->1 to 0->50 would result in 25)
  **/
  @:ufunction(BlueprintCallable) static public function MapRangeClamped(Value : unreal.Float32, InRangeA : unreal.Float32, InRangeB : unreal.Float32, OutRangeA : unreal.Float32, OutRangeB : unreal.Float32) : unreal.Float32;
  
  /**
    Multiplies the input value by pi.
  **/
  @:ufunction(BlueprintCallable) static public function MultiplyByPi(Value : unreal.Float32) : unreal.Float32;
  
  /**
    Interpolate between A and B, applying an ease in/out function.  Exp controls the degree of the curve.
  **/
  @:ufunction(BlueprintCallable) static public function FInterpEaseInOut(A : unreal.Float32, B : unreal.Float32, Alpha : unreal.Float32, Exponent : unreal.Float32) : unreal.Float32;
  
  /**
    Simple function to create a pulsating scalar value
    
    @param  InCurrentTime  Current absolute time
    @param  InPulsesPerSecond  How many full pulses per second?
    @param  InPhase  Optional phase amount, between 0.0 and 1.0 (to synchronize pulses)
    
    @return  Pulsating value (0.0-1.0)
  **/
  @:ufunction(BlueprintCallable) static public function MakePulsatingValue(InCurrentTime : unreal.Float32, InPulsesPerSecond : unreal.Float32 = 1.000000, InPhase : unreal.Float32 = 0.000000) : unreal.Float32;
  
  /**
    Returns a new rotation component value
    
    @param InCurrent is the current rotation value
    @param InDesired is the desired rotation value
    @param  is the rotation amount to apply
    
    @return a new rotation component value clamped in the range (-360,360)
  **/
  @:ufunction(BlueprintCallable) static public function FixedTurn(InCurrent : unreal.Float32, InDesired : unreal.Float32, InDeltaRate : unreal.Float32) : unreal.Float32;
  
  /**
    2D one vector constant (1,1)
  **/
  @:ufunction(BlueprintCallable) static public function Vector2D_One() : unreal.FVector2D;
  
  /**
    2D unit vector constant along the 45 degree angle or symmetrical positive axes (sqrt(.5),sqrt(.5)) or (.707,.707). https://en.wikipedia.org/wiki/Unit_vector
  **/
  @:ufunction(BlueprintCallable) static public function Vector2D_Unit45Deg() : unreal.FVector2D;
  
  /**
    2D zero vector constant (0,0)
  **/
  @:ufunction(BlueprintCallable) static public function Vector2D_Zero() : unreal.FVector2D;
  
  /**
    Makes a 2d vector {X, Y}
  **/
  @:ufunction(BlueprintCallable) static public function MakeVector2D(X : unreal.Float32, Y : unreal.Float32) : unreal.FVector2D;
  
  /**
    Breaks a 2D vector apart into X, Y.
  **/
  @:ufunction(BlueprintCallable) static public function BreakVector2D(InVec : unreal.FVector2D, X : unreal.Float32, Y : unreal.Float32) : Void;
  
  /**
    Convert a Vector2D to a Vector
  **/
  @:ufunction(BlueprintCallable) static public function Conv_Vector2DToVector(InVector2D : unreal.FVector2D, Z : unreal.Float32 = 0.000000) : unreal.FVector;
  
  /**
    Convert a Vector2D to a Vector
  **/
  @:ufunction(BlueprintCallable) static public function Conv_Vector2DToIntPoint(InVector2D : unreal.FVector2D) : unreal.FIntPoint;
  
  /**
    Returns addition of Vector A and Vector B (A + B)
  **/
  @:ufunction(BlueprintCallable) static public function Add_Vector2DVector2D(A : unreal.FVector2D, B : unreal.FVector2D) : unreal.FVector2D;
  
  /**
    Returns Vector A added by B
  **/
  @:ufunction(BlueprintCallable) static public function Add_Vector2DFloat(A : unreal.FVector2D, B : unreal.Float32) : unreal.FVector2D;
  
  /**
    Returns subtraction of Vector B from Vector A (A - B)
  **/
  @:ufunction(BlueprintCallable) static public function Subtract_Vector2DVector2D(A : unreal.FVector2D, B : unreal.FVector2D) : unreal.FVector2D;
  
  /**
    Returns Vector A subtracted by B
  **/
  @:ufunction(BlueprintCallable) static public function Subtract_Vector2DFloat(A : unreal.FVector2D, B : unreal.Float32) : unreal.FVector2D;
  
  /**
    Element-wise Vector multiplication (Result = {A.x*B.x, A.y*B.y})
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_Vector2DVector2D(A : unreal.FVector2D, B : unreal.FVector2D) : unreal.FVector2D;
  
  /**
    Returns Vector A scaled by B
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_Vector2DFloat(A : unreal.FVector2D, B : unreal.Float32) : unreal.FVector2D;
  
  /**
    Element-wise Vector divide (Result = {A.x/B.x, A.y/B.y})
  **/
  @:ufunction(BlueprintCallable) static public function Divide_Vector2DVector2D(A : unreal.FVector2D, B : unreal.FVector2D) : unreal.FVector2D;
  
  /**
    Returns Vector A divided by B
  **/
  @:ufunction(BlueprintCallable) static public function Divide_Vector2DFloat(A : unreal.FVector2D, B : unreal.Float32 = 1.000000) : unreal.FVector2D;
  
  /**
    Returns true if vector A is equal to vector B (A == B)
  **/
  @:ufunction(BlueprintCallable) static public function EqualExactly_Vector2DVector2D(A : unreal.FVector2D, B : unreal.FVector2D) : Bool;
  
  /**
    Returns true if vector2D A is equal to vector2D B (A == B) within a specified error tolerance
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_Vector2DVector2D(A : unreal.FVector2D, B : unreal.FVector2D, ErrorTolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Returns true if vector2D A is not equal to vector2D B (A != B) within a specified error tolerance
  **/
  @:ufunction(BlueprintCallable) static public function NotEqualExactly_Vector2DVector2D(A : unreal.FVector2D, B : unreal.FVector2D) : Bool;
  
  /**
    Returns true if vector2D A is not equal to vector2D B (A != B) within a specified error tolerance
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_Vector2DVector2D(A : unreal.FVector2D, B : unreal.FVector2D, ErrorTolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Gets a negated copy of the vector.
  **/
  @:ufunction(BlueprintCallable) static public function Negated2D(A : unreal.Const<unreal.PRef<unreal.FVector2D>>) : unreal.FVector2D;
  
  /**
    Set the values of the vector directly.
    
    @param InX New X coordinate.
    @param InY New Y coordinate.
  **/
  @:ufunction(BlueprintCallable) static public function Set2D(A : unreal.PRef<unreal.FVector2D>, X : unreal.Float32, Y : unreal.Float32) : Void;
  
  /**
    Creates a copy of this vector with both axes clamped to the given range.
    @return New vector with clamped axes.
  **/
  @:ufunction(BlueprintCallable) static public function ClampAxes2D(A : unreal.FVector2D, MinAxisVal : unreal.Float32, MaxAxisVal : unreal.Float32) : unreal.FVector2D;
  
  /**
    Returns the cross product of two 2d vectors - see  http://mathworld.wolfram.com/CrossProduct.html
  **/
  @:ufunction(BlueprintCallable) static public function CrossProduct2D(A : unreal.FVector2D, B : unreal.FVector2D) : unreal.Float32;
  
  /**
    Distance between two 2D points.
    
    @param V1 The first point.
    @param V2 The second point.
    @return The distance between two 2D points.
  **/
  @:ufunction(BlueprintCallable) static public function Distance2D(V1 : unreal.FVector2D, V2 : unreal.FVector2D) : unreal.Float32;
  
  /**
    Squared distance between two 2D points.
    
    @param V1 The first point.
    @param V2 The second point.
    @return The squared distance between two 2D points.
  **/
  @:ufunction(BlueprintCallable) static public function DistanceSquared2D(V1 : unreal.FVector2D, V2 : unreal.FVector2D) : unreal.Float32;
  
  /**
    Returns the dot product of two 2d vectors - see http://mathworld.wolfram.com/DotProduct.html
  **/
  @:ufunction(BlueprintCallable) static public function DotProduct2D(A : unreal.FVector2D, B : unreal.FVector2D) : unreal.Float32;
  
  /**
    Get a copy of this vector with absolute value of each component.
    
    @return A copy of this vector with absolute value of each component.
  **/
  @:ufunction(BlueprintCallable) static public function GetAbs2D(A : unreal.FVector2D) : unreal.FVector2D;
  
  /**
    Get the maximum absolute value of the vector's components.
    
    @return The maximum absolute value of the vector's components.
  **/
  @:ufunction(BlueprintCallable) static public function GetAbsMax2D(A : unreal.FVector2D) : unreal.Float32;
  
  /**
    Get the maximum value of the vector's components.
    
    @return The maximum value of the vector's components.
  **/
  @:ufunction(BlueprintCallable) static public function GetMax2D(A : unreal.FVector2D) : unreal.Float32;
  
  /**
    Get the minimum value of the vector's components.
    
    @return The minimum value of the vector's components.
  **/
  @:ufunction(BlueprintCallable) static public function GetMin2D(A : unreal.FVector2D) : unreal.Float32;
  
  /**
    Rotates around axis (0,0,1)
    
    @param AngleDeg Angle to rotate (in degrees)
    @return Rotated Vector
  **/
  @:ufunction(BlueprintCallable) static public function GetRotated2D(A : unreal.FVector2D, AngleDeg : unreal.Float32) : unreal.FVector2D;
  
  /**
    Checks whether vector is near to zero within a specified tolerance.
    
    @param Tolerance Error tolerance.
    @return true if vector is in tolerance to zero, otherwise false.
  **/
  @:ufunction(BlueprintCallable) static public function IsNearlyZero2D(A : unreal.Const<unreal.PRef<unreal.FVector2D>>, Tolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Checks whether all components of the vector are exactly zero.
    
    @return true if vector is exactly zero, otherwise false.
  **/
  @:ufunction(BlueprintCallable) static public function IsZero2D(A : unreal.Const<unreal.PRef<unreal.FVector2D>>) : Bool;
  
  /**
    Tries to reach Target based on distance from Current position, giving a nice smooth feeling when tracking a position.
    
    @param               Current                 Actual position
    @param               Target                  Target position
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  @:ufunction(BlueprintCallable) static public function Vector2DInterpTo(Current : unreal.FVector2D, Target : unreal.FVector2D, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FVector2D;
  
  /**
    Tries to reach Target at a constant rate.
    
    @param               Current                 Actual position
    @param               Target                  Target position
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  @:ufunction(BlueprintCallable) static public function Vector2DInterpTo_Constant(Current : unreal.FVector2D, Target : unreal.FVector2D, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FVector2D;
  
  /**
    Gets a normalized copy of the vector, checking it is safe to do so based on the length.
    Returns zero vector if vector length is too small to safely normalize.
    
    @param Tolerance Minimum squared length of vector for normalization.
    @return A normalized copy of the vector if safe, (0,0) otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function NormalSafe2D(A : unreal.FVector2D, Tolerance : unreal.Float32 = 0.000000) : unreal.FVector2D;
  
  /**
    Returns a unit normal version of the 2D vector
  **/
  @:ufunction(BlueprintCallable) static public function Normal2D(A : unreal.FVector2D) : unreal.FVector2D;
  
  /**
    Normalize this vector in-place if it is large enough, set it to (0,0) otherwise.
    
    @param Tolerance Minimum squared length of vector for normalization.
    @see NormalSafe2D()
  **/
  @:ufunction(BlueprintCallable) static public function Normalize2D(A : unreal.PRef<unreal.FVector2D>, Tolerance : unreal.Float32 = 0.000000) : Void;
  
  /**
    Converts spherical coordinates on the unit sphere into a Cartesian unit length vector.
  **/
  @:ufunction(BlueprintCallable) static public function Spherical2DToUnitCartesian(A : unreal.FVector2D) : unreal.FVector;
  
  /**
    Util to convert this vector into a unit direction vector and its original length.
    
    @param OutDir Reference passed in to store unit direction vector.
    @param OutLength Reference passed in to store length of the vector.
  **/
  @:ufunction(BlueprintCallable) static public function ToDirectionAndLength2D(A : unreal.FVector2D, OutDir : unreal.PRef<unreal.FVector2D>, OutLength : unreal.Float32) : Void;
  
  /**
    Get this vector as a vector where each component has been rounded to the nearest int.
    
    @return New FVector2D from this vector that is rounded.
  **/
  @:ufunction(BlueprintCallable) static public function ToRounded2D(A : unreal.FVector2D) : unreal.FVector2D;
  
  /**
    Get a copy of the vector as sign only.
    Each component is set to +1 or -1, with the sign of zero treated as +1.
    
    @return A copy of the vector with each component set to +1 or -1
  **/
  @:ufunction(BlueprintCallable) static public function ToSign2D(A : unreal.FVector2D) : unreal.FVector2D;
  
  /**
    Returns the length of a 2D Vector.
  **/
  @:ufunction(BlueprintCallable) static public function VSize2D(A : unreal.FVector2D) : unreal.Float32;
  
  /**
    Returns the squared length of a 2D Vector.
  **/
  @:ufunction(BlueprintCallable) static public function VSize2DSquared(A : unreal.FVector2D) : unreal.Float32;
  
  /**
    3D vector zero constant (0,0,0)
  **/
  @:ufunction(BlueprintCallable) static public function Vector_Zero() : unreal.FVector;
  
  /**
    3D vector one constant (1,1,1)
  **/
  @:ufunction(BlueprintCallable) static public function Vector_One() : unreal.FVector;
  
  /**
    3D vector Unreal forward direction constant (1,0,0)
  **/
  @:ufunction(BlueprintCallable) static public function Vector_Forward() : unreal.FVector;
  
  /**
    3D vector Unreal backward direction constant (-1,0,0)
  **/
  @:ufunction(BlueprintCallable) static public function Vector_Backward() : unreal.FVector;
  
  /**
    3D vector Unreal up direction constant (0,0,1)
  **/
  @:ufunction(BlueprintCallable) static public function Vector_Up() : unreal.FVector;
  
  /**
    3D vector Unreal down direction constant (0,0,-1)
  **/
  @:ufunction(BlueprintCallable) static public function Vector_Down() : unreal.FVector;
  
  /**
    3D vector Unreal right direction constant (0,1,0)
  **/
  @:ufunction(BlueprintCallable) static public function Vector_Right() : unreal.FVector;
  
  /**
    3D vector Unreal left direction constant (0,-1,0)
  **/
  @:ufunction(BlueprintCallable) static public function Vector_Left() : unreal.FVector;
  
  /**
    Makes a vector {X, Y, Z}
  **/
  @:ufunction(BlueprintCallable) static public function MakeVector(X : unreal.Float32, Y : unreal.Float32, Z : unreal.Float32) : unreal.FVector;
  
  /**
    Creates a directional vector from rotation values {Pitch, Yaw} supplied in degrees with specified Length
  **/
  @:ufunction(BlueprintCallable) static public function CreateVectorFromYawPitch(Yaw : unreal.Float32, Pitch : unreal.Float32, Length : unreal.Float32 = 1.000000) : unreal.FVector;
  
  /**
    Assign the values of the supplied vector.
    
    @param InVector Vector to copy values from.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_Assign(A : unreal.PRef<unreal.FVector>, InVector : unreal.Const<unreal.PRef<unreal.FVector>>) : Void;
  
  /**
    Set the values of the vector directly.
    
    @param InX New X coordinate.
    @param InY New Y coordinate.
    @param InZ New Z coordinate.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_Set(A : unreal.PRef<unreal.FVector>, X : unreal.Float32, Y : unreal.Float32, Z : unreal.Float32) : Void;
  
  /**
    Breaks a vector apart into X, Y, Z
  **/
  @:ufunction(BlueprintCallable) static public function BreakVector(InVec : unreal.FVector, X : unreal.Float32, Y : unreal.Float32, Z : unreal.Float32) : Void;
  
  /**
    Converts a vector to LinearColor
  **/
  @:ufunction(BlueprintCallable) static public function Conv_VectorToLinearColor(InVec : unreal.FVector) : unreal.FLinearColor;
  
  /**
    Convert a vector to a transform. Uses vector as location
  **/
  @:ufunction(BlueprintCallable) static public function Conv_VectorToTransform(InLocation : unreal.FVector) : unreal.FTransform;
  
  /**
    Convert a Vector to a Vector2D
  **/
  @:ufunction(BlueprintCallable) static public function Conv_VectorToVector2D(InVector : unreal.FVector) : unreal.FVector2D;
  
  /**
    Return the FRotator orientation corresponding to the direction in which the vector points.
    Sets Yaw and Pitch to the proper numbers, and sets Roll to zero because the roll can't be determined from a vector.
    
    @return FRotator from the Vector's direction, without any roll.
  **/
  @:ufunction(BlueprintCallable) static public function Conv_VectorToRotator(InVec : unreal.FVector) : unreal.FRotator;
  
  /**
    Create a rotation from an this axis and supplied angle (in degrees)
  **/
  @:ufunction(BlueprintCallable) static public function RotatorFromAxisAndAngle(Axis : unreal.FVector, Angle : unreal.Float32) : unreal.FRotator;
  
  /**
    Return the Quaternion orientation corresponding to the direction in which the vector points.
    Similar to the FRotator version, returns a result without roll such that it preserves the up vector.
    
    @note If you don't care about preserving the up vector and just want the most direct rotation, you can use the faster
    'FQuat::FindBetweenVectors(FVector::ForwardVector, YourVector)' or 'FQuat::FindBetweenNormals(...)' if you know the vector is of unit length.
    
    @return Quaternion from the Vector's direction, without any roll.
  **/
  @:ufunction(BlueprintCallable) static public function Conv_VectorToQuaterion(InVec : unreal.FVector) : unreal.FQuat;
  
  /**
    Vector addition
  **/
  @:ufunction(BlueprintCallable) static public function Add_VectorVector(A : unreal.FVector, B : unreal.FVector) : unreal.FVector;
  
  /**
    Adds a float to each component of a vector
  **/
  @:ufunction(BlueprintCallable) static public function Add_VectorFloat(A : unreal.FVector, B : unreal.Float32) : unreal.FVector;
  
  /**
    Adds an integer to each component of a vector
  **/
  @:ufunction(BlueprintCallable) static public function Add_VectorInt(A : unreal.FVector, B : unreal.Int32) : unreal.FVector;
  
  /**
    Vector subtraction
  **/
  @:ufunction(BlueprintCallable) static public function Subtract_VectorVector(A : unreal.FVector, B : unreal.FVector) : unreal.FVector;
  
  /**
    Subtracts a float from each component of a vector
  **/
  @:ufunction(BlueprintCallable) static public function Subtract_VectorFloat(A : unreal.FVector, B : unreal.Float32) : unreal.FVector;
  
  /**
    Subtracts an integer from each component of a vector
  **/
  @:ufunction(BlueprintCallable) static public function Subtract_VectorInt(A : unreal.FVector, B : unreal.Int32) : unreal.FVector;
  
  /**
    Element-wise Vector multiplication (Result = {A.x*B.x, A.y*B.y, A.z*B.z})
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_VectorVector(A : unreal.FVector, B : unreal.FVector) : unreal.FVector;
  
  /**
    Scales Vector A by B
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_VectorFloat(A : unreal.FVector, B : unreal.Float32) : unreal.FVector;
  
  /**
    Scales Vector A by B
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_VectorInt(A : unreal.FVector, B : unreal.Int32) : unreal.FVector;
  
  /**
    Element-wise Vector division (Result = {A.x/B.x, A.y/B.y, A.z/B.z})
  **/
  @:ufunction(BlueprintCallable) static public function Divide_VectorVector(A : unreal.FVector, @:opt("1.000000,1.000000,1.000000") B : unreal.FVector) : unreal.FVector;
  
  /**
    Vector divide by a float
  **/
  @:ufunction(BlueprintCallable) static public function Divide_VectorFloat(A : unreal.FVector, B : unreal.Float32 = 1.000000) : unreal.FVector;
  
  /**
    Vector divide by an integer
  **/
  @:ufunction(BlueprintCallable) static public function Divide_VectorInt(A : unreal.FVector, B : unreal.Int32 = 1) : unreal.FVector;
  
  /**
    Negate a vector.
  **/
  @:ufunction(BlueprintCallable) static public function NegateVector(A : unreal.FVector) : unreal.FVector;
  
  /**
    Returns true if vector A is equal to vector B (A == B)
  **/
  @:ufunction(BlueprintCallable) static public function EqualExactly_VectorVector(A : unreal.FVector, B : unreal.FVector) : Bool;
  
  /**
    Returns true if vector A is equal to vector B (A == B) within a specified error tolerance
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_VectorVector(A : unreal.FVector, B : unreal.FVector, ErrorTolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Returns true if vector A is not equal to vector B (A != B)
  **/
  @:ufunction(BlueprintCallable) static public function NotEqualExactly_VectorVector(A : unreal.FVector, B : unreal.FVector) : Bool;
  
  /**
    Returns true if vector A is not equal to vector B (A != B) within a specified error tolerance
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_VectorVector(A : unreal.FVector, B : unreal.FVector, ErrorTolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Returns the dot product of two 3d vectors - see http://mathworld.wolfram.com/DotProduct.html
  **/
  @:ufunction(BlueprintCallable) static public function Dot_VectorVector(A : unreal.FVector, B : unreal.FVector) : unreal.Float32;
  
  /**
    Returns the cross product of two 3d vectors - see http://mathworld.wolfram.com/CrossProduct.html
  **/
  @:ufunction(BlueprintCallable) static public function Cross_VectorVector(A : unreal.FVector, B : unreal.FVector) : unreal.FVector;
  
  /**
    Returns result of vector A rotated by Rotator B
  **/
  @:ufunction(BlueprintCallable) static public function GreaterGreater_VectorRotator(A : unreal.FVector, B : unreal.FRotator) : unreal.FVector;
  
  /**
    Returns result of vector A rotated by AngleDeg around Axis
  **/
  @:ufunction(BlueprintCallable) static public function RotateAngleAxis(InVect : unreal.FVector, AngleDeg : unreal.Float32, Axis : unreal.FVector) : unreal.FVector;
  
  /**
    Returns result of vector A rotated by the inverse of Rotator B
  **/
  @:ufunction(BlueprintCallable) static public function LessLess_VectorRotator(A : unreal.FVector, B : unreal.FRotator) : unreal.FVector;
  
  /**
    When this vector contains Euler angles (degrees), ensure that angles are between +/-180
  **/
  @:ufunction(BlueprintCallable) static public function Vector_UnwindEuler(A : unreal.PRef<unreal.FVector>) : Void;
  
  /**
    Create a copy of this vector, with its magnitude/size/length clamped between Min and Max.
  **/
  @:ufunction(BlueprintCallable) static public function ClampVectorSize(A : unreal.FVector, Min : unreal.Float32, Max : unreal.Float32) : unreal.FVector;
  
  /**
    Create a copy of this vector, with the 2D magnitude/size/length clamped between Min and Max. Z is unchanged.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_ClampSize2D(A : unreal.FVector, Min : unreal.Float32, Max : unreal.Float32) : unreal.FVector;
  
  /**
    Create a copy of this vector, with its maximum magnitude/size/length clamped to MaxSize.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_ClampSizeMax(A : unreal.FVector, Max : unreal.Float32) : unreal.FVector;
  
  /**
    Create a copy of this vector, with the maximum 2D magnitude/size/length clamped to MaxSize. Z is unchanged.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_ClampSizeMax2D(A : unreal.FVector, Max : unreal.Float32) : unreal.FVector;
  
  /**
    Find the minimum element (X, Y or Z) of a vector
  **/
  @:ufunction(BlueprintCallable) static public function GetMinElement(A : unreal.FVector) : unreal.Float32;
  
  /**
    Find the maximum element (X, Y or Z) of a vector
  **/
  @:ufunction(BlueprintCallable) static public function GetMaxElement(A : unreal.FVector) : unreal.Float32;
  
  /**
    Find the maximum absolute element (abs(X), abs(Y) or abs(Z)) of a vector
  **/
  @:ufunction(BlueprintCallable) static public function Vector_GetAbsMax(A : unreal.FVector) : unreal.Float32;
  
  /**
    Find the minimum absolute element (abs(X), abs(Y) or abs(Z)) of a vector
  **/
  @:ufunction(BlueprintCallable) static public function Vector_GetAbsMin(A : unreal.FVector) : unreal.Float32;
  
  /**
    Get a copy of this vector with absolute value of each component.
    
    @return A copy of this vector with absolute value of each component.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_GetAbs(A : unreal.FVector) : unreal.FVector;
  
  /**
    Find the minimum elements (X, Y and Z) between the two vector's components
  **/
  @:ufunction(BlueprintCallable) static public function Vector_ComponentMin(A : unreal.FVector, B : unreal.FVector) : unreal.FVector;
  
  /**
    Find the maximum elements (X, Y and Z) between the two vector's components
  **/
  @:ufunction(BlueprintCallable) static public function Vector_ComponentMax(A : unreal.FVector, B : unreal.FVector) : unreal.FVector;
  
  /**
    Get a copy of the vector as sign only.
    Each component is set to +1 or -1, with the sign of zero treated as +1.
    
    @param A copy of the vector with each component set to +1 or -1
  **/
  @:ufunction(BlueprintCallable) static public function Vector_GetSignVector(A : unreal.FVector) : unreal.FVector;
  
  /**
    Projects 2D components of vector based on Z.
    
    @return Projected version of vector based on Z.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_GetProjection(A : unreal.FVector) : unreal.FVector;
  
  /**
    Convert a direction vector into a 'heading' angle.
    
    @return 'Heading' angle between +/-PI radians. 0 is pointing down +X.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_HeadingAngle(A : unreal.FVector) : unreal.Float32;
  
  /**
    Returns the cosine of the angle between this vector and another projected onto the XY plane (no Z).
    
    @param B the other vector to find the 2D cosine of the angle with.
    @return The cosine.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_CosineAngle2D(A : unreal.FVector, B : unreal.FVector) : unreal.Float32;
  
  /**
    Converts a vector containing degree values to a vector containing radian values.
    
    @return Vector containing radian values
  **/
  @:ufunction(BlueprintCallable) static public function Vector_ToRadians(A : unreal.FVector) : unreal.FVector;
  
  /**
    Converts a vector containing radian values to a vector containing degree values.
    
    @return Vector  containing degree values
  **/
  @:ufunction(BlueprintCallable) static public function Vector_ToDegrees(A : unreal.FVector) : unreal.FVector;
  
  /**
    Converts a Cartesian unit vector into spherical coordinates on the unit sphere.
    @return Output Theta will be in the range [0, PI], and output Phi will be in the range [-PI, PI].
  **/
  @:ufunction(BlueprintCallable) static public function Vector_UnitCartesianToSpherical(A : unreal.FVector) : unreal.FVector2D;
  
  /**
    Find the unit direction vector from one position to another or (0,0,0) if positions are the same.
  **/
  @:ufunction(BlueprintCallable) static public function GetDirectionUnitVector(From : unreal.FVector, To : unreal.FVector) : unreal.FVector;
  
  /**
    Breaks a vector apart into Yaw, Pitch rotation values given in degrees. (non-clamped)
  **/
  @:ufunction(BlueprintCallable) static public function GetYawPitchFromVector(InVec : unreal.FVector, Yaw : unreal.Float32, Pitch : unreal.Float32) : Void;
  
  /**
    Breaks a direction vector apart into Azimuth (Yaw) and Elevation (Pitch) rotation values given in degrees. (non-clamped)
           Relative to the provided reference frame (an Actor's WorldTransform for example)
  **/
  @:ufunction(BlueprintCallable) static public function GetAzimuthAndElevation(InDirection : unreal.FVector, ReferenceFrame : unreal.Const<unreal.PRef<unreal.FTransform>>, Azimuth : unreal.Float32, Elevation : unreal.Float32) : Void;
  
  /**
    Find the average of an array of vectors
  **/
  @:ufunction(BlueprintCallable) static public function GetVectorArrayAverage(Vectors : unreal.Const<unreal.PRef<unreal.TArray<unreal.FVector>>>) : unreal.FVector;
  
  /**
    Rounds A to an integer with truncation towards zero for each element in a vector.  (e.g. -1.7 truncated to -1, 2.8 truncated to 2)
  **/
  @:ufunction(BlueprintCallable) static public function FTruncVector(InVector : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FIntVector;
  
  /**
    Distance between two points.
    
    @param V1 The first point.
    @param V2 The second point.
    @return The distance between two points.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_Distance(V1 : unreal.FVector, V2 : unreal.FVector) : unreal.Float32;
  
  /**
    Squared distance between two points.
    
    @param V1 The first point.
    @param V2 The second point.
    @return The squared distance between two points.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_DistanceSquared(V1 : unreal.FVector, V2 : unreal.FVector) : unreal.Float32;
  
  /**
    Euclidean distance between two points in the XY plane (ignoring Z).
    
    @param V1 The first point.
    @param V2 The second point.
    @return The distance between two points in the XY plane.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_Distance2D(V1 : unreal.FVector, V2 : unreal.FVector) : unreal.Float32;
  
  /**
    Squared euclidean distance between two points in the XY plane (ignoring Z).
    
    @param V1 The first point.
    @param V2 The second point.
    @return The distance between two points in the XY plane.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_Distance2DSquared(V1 : unreal.FVector, V2 : unreal.FVector) : unreal.Float32;
  
  /**
    Returns the length of the vector
  **/
  @:ufunction(BlueprintCallable) static public function VSize(A : unreal.FVector) : unreal.Float32;
  
  /**
    Returns the squared length of the vector
  **/
  @:ufunction(BlueprintCallable) static public function VSizeSquared(A : unreal.FVector) : unreal.Float32;
  
  /**
    Returns the length of the vector's XY components.
  **/
  @:ufunction(BlueprintCallable) static public function VSizeXY(A : unreal.FVector) : unreal.Float32;
  
  /**
    Returns the squared length of the vector's XY components.
  **/
  @:ufunction(BlueprintCallable) static public function VSizeXYSquared(A : unreal.FVector) : unreal.Float32;
  
  /**
    Checks whether vector is near to zero within a specified tolerance.
    
    @param Tolerance Error tolerance.
    @return true if vector is in tolerance to zero, otherwise false.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_IsNearlyZero(A : unreal.Const<unreal.PRef<unreal.FVector>>, Tolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Checks whether all components of the vector are exactly zero.
    
    @return true if vector is exactly zero, otherwise false.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_IsZero(A : unreal.Const<unreal.PRef<unreal.FVector>>) : Bool;
  
  /**
    Determines if any component is not a number (NAN)
    
    @return true if one or more components is NAN, otherwise false.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_IsNAN(A : unreal.Const<unreal.PRef<unreal.FVector>>) : Bool;
  
  /**
    Checks whether all components of this vector are the same, within a tolerance.
    
    @param Tolerance Error tolerance.
    @return true if the vectors are equal within tolerance limits, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_IsUniform(A : unreal.Const<unreal.PRef<unreal.FVector>>, Tolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Determines if vector is normalized / unit (length 1) within specified squared tolerance.
    
    @return true if unit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_IsUnit(A : unreal.Const<unreal.PRef<unreal.FVector>>, SquaredLenthTolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Determines if vector is normalized / unit (length 1).
    
    @return true if normalized, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_IsNormal(A : unreal.Const<unreal.PRef<unreal.FVector>>) : Bool;
  
  /**
    Gets a normalized unit copy of the vector, ensuring it is safe to do so based on the length.
    Returns zero vector if vector length is too small to safely normalize.
    
    @param Tolerance Minimum squared vector length.
    @return A normalized copy if safe, (0,0,0) otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function Normal(A : unreal.FVector, Tolerance : unreal.Float32 = 0.000100) : unreal.FVector;
  
  /**
    Gets a normalized unit copy of the 2D components of the vector, ensuring it is safe to do so. Z is set to zero.
    Returns zero vector if vector length is too small to normalize.
    
    @param Tolerance Minimum squared vector length.
    @return Normalized copy if safe, (0,0,0) otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_Normal2D(A : unreal.FVector, Tolerance : unreal.Float32 = 0.000100) : unreal.FVector;
  
  /**
    Calculates normalized unit version of vector without checking for zero length.
    
    @return Normalized version of vector.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_NormalUnsafe(A : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FVector;
  
  /**
    Normalize this vector in-place if it is large enough or set it to (0,0,0) otherwise.
    
    @param Tolerance Minimum squared length of vector for normalization.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_Normalize(A : unreal.PRef<unreal.FVector>, Tolerance : unreal.Float32 = 0.000000) : Void;
  
  /**
    Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)
  **/
  @:ufunction(BlueprintCallable) static public function VLerp(A : unreal.FVector, B : unreal.FVector, Alpha : unreal.Float32) : unreal.FVector;
  
  /**
    Easing between A and B using a specified easing function
  **/
  @:ufunction(BlueprintCallable) static public function VEase(A : unreal.FVector, B : unreal.FVector, Alpha : unreal.Float32, EasingFunc : unreal.EEasingFunc, BlendExp : unreal.Float32 = 2.000000, Steps : unreal.Int32 = 2) : unreal.FVector;
  
  /**
    Tries to reach Target based on distance from Current position, giving a nice smooth feeling when tracking a position.
    
    @param               Current                 Actual position
    @param               Target                  Target position
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  @:ufunction(BlueprintCallable) static public function VInterpTo(Current : unreal.FVector, Target : unreal.FVector, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FVector;
  
  /**
    Tries to reach Target at a constant rate.
    
    @param               Current                 Actual position
    @param               Target                  Target position
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  @:ufunction(BlueprintCallable) static public function VInterpTo_Constant(Current : unreal.FVector, Target : unreal.FVector, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FVector;
  
  /**
    Uses a simple spring model to interpolate a vector from Current to Target.
    
    @param Current                                Current value
    @param Target                                 Target value
    @param SpringState                    Data related to spring model (velocity, error, etc..) - Create a unique variable per spring
    @param Stiffness                              How stiff the spring model is (more stiffness means more oscillation around the target value)
    @param CriticalDampingFactor  How much damping to apply to the spring (0 means no damping, 1 means critically damped which means no oscillation)
    @param Mass                                   Multiplier that acts like mass on a spring
  **/
  @:ufunction(BlueprintCallable) static public function VectorSpringInterp(Current : unreal.FVector, Target : unreal.FVector, SpringState : unreal.PRef<unreal.FVectorSpringState>, Stiffness : unreal.Float32, CriticalDampingFactor : unreal.Float32, DeltaTime : unreal.Float32, Mass : unreal.Float32 = 1.000000) : unreal.FVector;
  
  /**
    Gets the reciprocal of this vector, avoiding division by zero.
    Zero components are set to BIG_NUMBER.
    
    @return Reciprocal of this vector.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_Reciprocal(A : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FVector;
  
  /**
    Given a direction vector and a surface normal, returns the vector reflected across the surface normal.
    Produces a result like shining a laser at a mirror!
    
    @param Direction Direction vector the ray is coming from.
    @param SurfaceNormal A normal of the surface the ray should be reflected on.
    
    @returns Reflected vector.
  **/
  @:ufunction(BlueprintCallable) static public function GetReflectionVector(Direction : unreal.FVector, SurfaceNormal : unreal.FVector) : unreal.FVector;
  
  /**
    Given a direction vector and a surface normal, returns the vector reflected across the surface normal.
    Produces a result like shining a laser at a mirror!
    
    @param InVect Direction vector the ray is coming from.
    @param InNormal A normal of the surface the ray should be reflected on.
    
    @returns Reflected vector.
  **/
  @:ufunction(BlueprintCallable) static public function MirrorVectorByNormal(InVect : unreal.FVector, InNormal : unreal.FVector) : unreal.FVector;
  
  /**
    Mirrors a vector about a plane.
    
    @param Plane Plane to mirror about.
    @return Mirrored vector.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_MirrorByPlane(A : unreal.FVector, InPlane : unreal.Const<unreal.PRef<unreal.FPlane>>) : unreal.FVector;
  
  /**
    Gets a copy of this vector snapped to a grid.
    
    @param InGridSize Grid dimension / step.
    @return A copy of this vector snapped to a grid.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_SnappedToGrid(InVect : unreal.FVector, InGridSize : unreal.Float32) : unreal.FVector;
  
  /**
    Get a copy of this vector, clamped inside of an axis aligned cube centered at the origin.
    
    @param InRadius Half size of the cube (or radius of sphere circumscribed in the cube).
    @return A copy of this vector, bound by cube.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_BoundedToCube(InVect : unreal.FVector, InRadius : unreal.Float32) : unreal.FVector;
  
  /**
    Add a vector to this and clamp the result to an axis aligned cube centered at the origin.
    
    @param InAddVect Vector to add.
    @param InRadius Half size of the cube.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_AddBounded(A : unreal.PRef<unreal.FVector>, InAddVect : unreal.FVector, InRadius : unreal.Float32) : Void;
  
  /**
    Get a copy of this vector, clamped inside of the specified axis aligned cube.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_BoundedToBox(InVect : unreal.FVector, InBoxMin : unreal.FVector, InBoxMax : unreal.FVector) : unreal.FVector;
  
  /**
    Gets a copy of this vector projected onto the input vector, which is assumed to be unit length.
    
    @param  InNormal Vector to project onto (assumed to be unit length).
    @return Projected vector.
  **/
  @:ufunction(BlueprintCallable) static public function Vector_ProjectOnToNormal(V : unreal.FVector, InNormal : unreal.FVector) : unreal.FVector;
  
  /**
    Projects one vector (V) onto another (Target) and returns the projected vector.
    If Target is nearly zero in length, returns the zero vector.
    
    @param  V Vector to project.
    @param  Target Vector on which we are projecting.
    @return V projected on to Target.
  **/
  @:ufunction(BlueprintCallable) static public function ProjectVectorOnToVector(V : unreal.FVector, Target : unreal.FVector) : unreal.FVector;
  
  /**
    Projects/snaps a point onto a plane defined by a point on the plane and a plane normal.
    
    @param  Point Point to project onto the plane.
    @param  PlaneBase A point on the plane.
    @param  PlaneNormal Normal of the plane.
    @return Point projected onto the plane.
  **/
  @:ufunction(BlueprintCallable) static public function ProjectPointOnToPlane(Point : unreal.FVector, PlaneBase : unreal.FVector, PlaneNormal : unreal.FVector) : unreal.FVector;
  
  /**
    Projects a vector onto a plane defined by a normalized vector (PlaneNormal).
    
    @param  V Vector to project onto the plane.
    @param  PlaneNormal Normal of the plane.
    @return Vector projected onto the plane.
  **/
  @:ufunction(BlueprintCallable) static public function ProjectVectorOnToPlane(V : unreal.FVector, PlaneNormal : unreal.FVector) : unreal.FVector;
  
  /**
    Find closest points between 2 segments.
    
    @param       Segment1Start   Start of the 1st segment.
    @param       Segment1End             End of the 1st segment.
    @param       Segment2Start   Start of the 2nd segment.
    @param       Segment2End             End of the 2nd segment.
    @param       Segment1Point   Closest point on segment 1 to segment 2.
    @param       Segment2Point   Closest point on segment 2 to segment 1.
  **/
  @:ufunction(BlueprintCallable) static public function FindNearestPointsOnLineSegments(Segment1Start : unreal.FVector, Segment1End : unreal.FVector, Segment2Start : unreal.FVector, Segment2End : unreal.FVector, Segment1Point : unreal.PRef<unreal.FVector>, Segment2Point : unreal.PRef<unreal.FVector>) : Void;
  
  /**
    Find the closest point on a segment to a given point.
    
    @param Point                 Point for which we find the closest point on the segment.
    @param SegmentStart  Start of the segment.
    @param SegmentEnd    End of the segment.
    @return The closest point on the segment to the given point.
  **/
  @:ufunction(BlueprintCallable) static public function FindClosestPointOnSegment(Point : unreal.FVector, SegmentStart : unreal.FVector, SegmentEnd : unreal.FVector) : unreal.FVector;
  
  /**
    Find the closest point on an infinite line to a given point.
    
    @param Point                 Point for which we find the closest point on the line.
    @param LineOrigin    Point of reference on the line.
    @param LineDirection Direction of the line. Not required to be normalized.
    @return The closest point on the line to the given point.
  **/
  @:ufunction(BlueprintCallable) static public function FindClosestPointOnLine(Point : unreal.FVector, LineOrigin : unreal.FVector, LineDirection : unreal.FVector) : unreal.FVector;
  
  /**
    Find the distance from a point to the closest point on a segment.
    
    @param Point                  Point for which we find the distance to the closest point on the segment.
    @param SegmentStart   Start of the segment.
    @param SegmentEnd             End of the segment.
    @return The distance from the given point to the closest point on the segment.
  **/
  @:ufunction(BlueprintCallable) static public function GetPointDistanceToSegment(Point : unreal.FVector, SegmentStart : unreal.FVector, SegmentEnd : unreal.FVector) : unreal.Float32;
  
  /**
    Find the distance from a point to the closest point on an infinite line.
    
    @param Point                  Point for which we find the distance to the closest point on the line.
    @param LineOrigin             Point of reference on the line.
    @param LineDirection  Direction of the line. Not required to be normalized.
    @return The distance from the given point to the closest point on the line.
  **/
  @:ufunction(BlueprintCallable) static public function GetPointDistanceToLine(Point : unreal.FVector, LineOrigin : unreal.FVector, LineDirection : unreal.FVector) : unreal.Float32;
  
  /**
    Returns a random vector with length of 1
  **/
  @:ufunction(BlueprintCallable) static public function RandomUnitVector() : unreal.FVector;
  
  /**
    Returns a random point within the specified bounding box using the first vector as an origin and the second as the box extents.
  **/
  @:ufunction(BlueprintCallable) static public function RandomPointInBoundingBox(Origin : unreal.FVector, BoxExtent : unreal.FVector) : unreal.FVector;
  
  /**
    Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
    @param ConeDir                                       The base "center" direction of the cone.
    @param ConeHalfAngleInRadians        The half-angle of the cone (from ConeDir to edge), in radians.
  **/
  @:ufunction(BlueprintCallable) static public function RandomUnitVectorInConeInRadians(ConeDir : unreal.FVector, ConeHalfAngleInRadians : unreal.Float32) : unreal.FVector;
  
  /**
    Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
    @param ConeDir                                       The base "center" direction of the cone.
    @param ConeHalfAngleInDegrees        The half-angle of the cone (from ConeDir to edge), in degrees.
  **/
  @:ufunction(BlueprintCallable) static public function RandomUnitVectorInConeInDegrees(ConeDir : unreal.FVector, ConeHalfAngleInDegrees : unreal.Float32) : unreal.FVector;
  
  /**
    Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
    The shape of the cone can be modified according to the yaw and pitch angles.
    
    @param MaxYawInRadians        The yaw angle of the cone (from ConeDir to horizontal edge), in radians.
    @param MaxPitchInRadians      The pitch angle of the cone (from ConeDir to vertical edge), in radians.
  **/
  @:ufunction(BlueprintCallable) static public function RandomUnitVectorInEllipticalConeInRadians(ConeDir : unreal.FVector, MaxYawInRadians : unreal.Float32, MaxPitchInRadians : unreal.Float32) : unreal.FVector;
  
  /**
    Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
    The shape of the cone can be modified according to the yaw and pitch angles.
    
    @param MaxYawInDegrees        The yaw angle of the cone (from ConeDir to horizontal edge), in degrees.
    @param MaxPitchInDegrees      The pitch angle of the cone (from ConeDir to vertical edge), in degrees.
  **/
  @:ufunction(BlueprintCallable) static public function RandomUnitVectorInEllipticalConeInDegrees(ConeDir : unreal.FVector, MaxYawInDegrees : unreal.Float32, MaxPitchInDegrees : unreal.Float32) : unreal.FVector;
  
  /**
    4D vector zero constant (0,0,0)
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_Zero() : unreal.FVector4;
  
  /**
    Makes a 4D vector {X, Y, Z, W}
  **/
  @:ufunction(BlueprintCallable) static public function MakeVector4(X : unreal.Float32, Y : unreal.Float32, Z : unreal.Float32, W : unreal.Float32) : unreal.FVector4;
  
  /**
    Breaks a 4D vector apart into X, Y, Z, W.
  **/
  @:ufunction(BlueprintCallable) static public function BreakVector4(InVec : unreal.Const<unreal.PRef<unreal.FVector4>>, X : unreal.Float32, Y : unreal.Float32, Z : unreal.Float32, W : unreal.Float32) : Void;
  
  /**
    Convert a Vector4 to a Vector (dropping the W element)
  **/
  @:ufunction(BlueprintCallable) static public function Conv_Vector4ToVector(InVector4 : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.FVector;
  
  /**
    Return the FRotator orientation corresponding to the direction in which the vector points.
    Sets Yaw and Pitch to the proper numbers, and sets Roll to zero because the roll can't be determined from a vector.
    
    @return FRotator from the Vector's direction, without any roll.
  **/
  @:ufunction(BlueprintCallable) static public function Conv_Vector4ToRotator(InVec : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.FRotator;
  
  /**
    Return the Quaternion orientation corresponding to the direction in which the vector points.
    Similar to the FRotator version, returns a result without roll such that it preserves the up vector.
    
    @note If you don't care about preserving the up vector and just want the most direct rotation, you can use the faster
    'FQuat::FindBetweenVectors(FVector::ForwardVector, YourVector)' or 'FQuat::FindBetweenNormals(...)' if you know the vector is of unit length.
    
    @return Quaternion from the Vector's direction, without any roll.
  **/
  @:ufunction(BlueprintCallable) static public function Conv_Vector4ToQuaterion(InVec : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.FQuat;
  
  /**
    Returns addition of Vector A and Vector B (A + B)
  **/
  @:ufunction(BlueprintCallable) static public function Add_Vector4Vector4(A : unreal.Const<unreal.PRef<unreal.FVector4>>, B : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.FVector4;
  
  /**
    Returns subtraction of Vector B from Vector A (A - B)
  **/
  @:ufunction(BlueprintCallable) static public function Subtract_Vector4Vector4(A : unreal.Const<unreal.PRef<unreal.FVector4>>, B : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.FVector4;
  
  /**
    Element-wise Vector multiplication (Result = {A.x*B.x, A.y*B.y, A.z*B.z, A.w*B.w})
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_Vector4Vector4(A : unreal.Const<unreal.PRef<unreal.FVector4>>, B : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.FVector4;
  
  /**
    Element-wise Vector divide (Result = {A.x/B.x, A.y/B.y, A.z/B.z, A.w/B.w})
  **/
  @:ufunction(BlueprintCallable) static public function Divide_Vector4Vector4(A : unreal.Const<unreal.PRef<unreal.FVector4>>, B : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.FVector4;
  
  /**
    Returns true if vector A is equal to vector B (A == B)
  **/
  @:ufunction(BlueprintCallable) static public function EqualExactly_Vector4Vector4(A : unreal.Const<unreal.PRef<unreal.FVector4>>, B : unreal.Const<unreal.PRef<unreal.FVector4>>) : Bool;
  
  /**
    Returns true if vector A is equal to vector B (A == B) within a specified error tolerance
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_Vector4Vector4(A : unreal.Const<unreal.PRef<unreal.FVector4>>, B : unreal.Const<unreal.PRef<unreal.FVector4>>, ErrorTolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Returns true if vector A is not equal to vector B (A != B) within a specified error tolerance
  **/
  @:ufunction(BlueprintCallable) static public function NotEqualExactly_Vector4Vector4(A : unreal.Const<unreal.PRef<unreal.FVector4>>, B : unreal.Const<unreal.PRef<unreal.FVector4>>) : Bool;
  
  /**
    Returns true if vector A is not equal to vector B (A != B) within a specified error tolerance
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_Vector4Vector4(A : unreal.Const<unreal.PRef<unreal.FVector4>>, B : unreal.Const<unreal.PRef<unreal.FVector4>>, ErrorTolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Gets a negated copy of the vector. Equivalent to -Vector for scripts.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_Negated(A : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.FVector4;
  
  /**
    Assign the values of the supplied vector.
    
    @param InVector Vector to copy values from.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_Assign(A : unreal.PRef<unreal.FVector4>, InVector : unreal.Const<unreal.PRef<unreal.FVector4>>) : Void;
  
  /**
    Set the values of the vector directly.
    
    @param InX New X coordinate.
    @param InY New Y coordinate.
    @param InZ New Z coordinate.
    @param InW New W coordinate.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_Set(A : unreal.PRef<unreal.FVector4>, X : unreal.Float32, Y : unreal.Float32, Z : unreal.Float32, W : unreal.Float32) : Void;
  
  /**
    Returns the cross product of two vectors - see  http://mathworld.wolfram.com/CrossProduct.html
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_CrossProduct3(A : unreal.Const<unreal.PRef<unreal.FVector4>>, B : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.FVector4;
  
  /**
    Returns the dot product of two vectors - see http://mathworld.wolfram.com/DotProduct.html
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_DotProduct(A : unreal.Const<unreal.PRef<unreal.FVector4>>, B : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.Float32;
  
  /**
    Returns the dot product of two vectors - see http://mathworld.wolfram.com/DotProduct.html The W element is ignored.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_DotProduct3(A : unreal.Const<unreal.PRef<unreal.FVector4>>, B : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.Float32;
  
  /**
    Determines if any component is not a number (NAN)
    
    @return true if one or more components is NAN, otherwise false.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_IsNAN(A : unreal.Const<unreal.PRef<unreal.FVector4>>) : Bool;
  
  /**
    Checks whether vector is near to zero within a specified tolerance. The W element is ignored.
    
    @param Tolerance Error tolerance.
    @return true if vector is in tolerance to zero, otherwise false.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_IsNearlyZero3(A : unreal.Const<unreal.PRef<unreal.FVector4>>, Tolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Checks whether all components of the vector are exactly zero.
    
    @return true if vector is exactly zero, otherwise false.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_IsZero(A : unreal.Const<unreal.PRef<unreal.FVector4>>) : Bool;
  
  /**
    Returns the length of the vector.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_Size(A : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.Float32;
  
  /**
    Returns the squared length of the vector.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_SizeSquared(A : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.Float32;
  
  /**
    Returns the length of the vector. The W element is ignored.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_Size3(A : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.Float32;
  
  /**
    Returns the squared length of the vector. The W element is ignored.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_SizeSquared3(A : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.Float32;
  
  /**
    Determines if vector is normalized / unit (length 1) within specified squared tolerance. The W element is ignored.
    
    @return true if unit, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_IsUnit3(A : unreal.Const<unreal.PRef<unreal.FVector4>>, SquaredLenthTolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Determines if vector is normalized / unit (length 1). The W element is ignored.
    
    @return true if normalized, false otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_IsNormal3(A : unreal.Const<unreal.PRef<unreal.FVector4>>) : Bool;
  
  /**
    Gets a normalized unit copy of the vector, ensuring it is safe to do so based on the length. The W element is ignored and the returned vector has W=0.
    Returns zero vector if vector length is too small to safely normalize.
    
    @param Tolerance Minimum squared vector length.
    @return A normalized copy if safe, (0,0,0) otherwise.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_Normal3(A : unreal.Const<unreal.PRef<unreal.FVector4>>, Tolerance : unreal.Float32 = 0.000100) : unreal.FVector4;
  
  /**
    Calculates normalized unit version of vector without checking for zero length. The W element is ignored and the returned vector has W=0.
    
    @return Normalized version of vector.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_NormalUnsafe3(A : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.FVector4;
  
  /**
    Normalize this vector in-place if it is large enough or set it to (0,0,0,0) otherwise. The W element is ignored and the returned vector has W=0.
    
    @param Tolerance Minimum squared length of vector for normalization.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_Normalize3(A : unreal.PRef<unreal.FVector4>, Tolerance : unreal.Float32 = 0.000000) : Void;
  
  /**
    Given a direction vector and a surface normal, returns the vector reflected across the surface normal.
    Produces a result like shining a laser at a mirror!
    The W element is ignored.
    
    @param Direction Direction vector the ray is coming from.
    @param SurfaceNormal A normal of the surface the ray should be reflected on.
    
    @returns Reflected vector.
  **/
  @:ufunction(BlueprintCallable) static public function Vector4_MirrorByVector3(Direction : unreal.Const<unreal.PRef<unreal.FVector4>>, SurfaceNormal : unreal.Const<unreal.PRef<unreal.FVector4>>) : unreal.FVector4;
  
  /**
    Makes a rotator {Roll, Pitch, Yaw} from rotation values supplied in degrees
  **/
  @:ufunction(BlueprintCallable) static public function MakeRotator(Roll : unreal.Float32, Pitch : unreal.Float32, Yaw : unreal.Float32) : unreal.FRotator;
  
  /**
    Builds a rotator given only a XAxis. Y and Z are unspecified but will be orthonormal. XAxis need not be normalized.
  **/
  @:ufunction(BlueprintCallable) static public function MakeRotFromX(X : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a rotation matrix given only a YAxis. X and Z are unspecified but will be orthonormal. YAxis need not be normalized.
  **/
  @:ufunction(BlueprintCallable) static public function MakeRotFromY(Y : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a rotation matrix given only a ZAxis. X and Y are unspecified but will be orthonormal. ZAxis need not be normalized.
  **/
  @:ufunction(BlueprintCallable) static public function MakeRotFromZ(Z : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a matrix with given X and Y axes. X will remain fixed, Y may be changed minimally to enforce orthogonality. Z will be computed. Inputs need not be normalized.
  **/
  @:ufunction(BlueprintCallable) static public function MakeRotFromXY(X : unreal.Const<unreal.PRef<unreal.FVector>>, Y : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a matrix with given X and Z axes. X will remain fixed, Z may be changed minimally to enforce orthogonality. Y will be computed. Inputs need not be normalized.
  **/
  @:ufunction(BlueprintCallable) static public function MakeRotFromXZ(X : unreal.Const<unreal.PRef<unreal.FVector>>, Z : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a matrix with given Y and X axes. Y will remain fixed, X may be changed minimally to enforce orthogonality. Z will be computed. Inputs need not be normalized.
  **/
  @:ufunction(BlueprintCallable) static public function MakeRotFromYX(Y : unreal.Const<unreal.PRef<unreal.FVector>>, X : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a matrix with given Y and Z axes. Y will remain fixed, Z may be changed minimally to enforce orthogonality. X will be computed. Inputs need not be normalized.
  **/
  @:ufunction(BlueprintCallable) static public function MakeRotFromYZ(Y : unreal.Const<unreal.PRef<unreal.FVector>>, Z : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a matrix with given Z and X axes. Z will remain fixed, X may be changed minimally to enforce orthogonality. Y will be computed. Inputs need not be normalized.
  **/
  @:ufunction(BlueprintCallable) static public function MakeRotFromZX(Z : unreal.Const<unreal.PRef<unreal.FVector>>, X : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Builds a matrix with given Z and Y axes. Z will remain fixed, Y may be changed minimally to enforce orthogonality. X will be computed. Inputs need not be normalized.
  **/
  @:ufunction(BlueprintCallable) static public function MakeRotFromZY(Z : unreal.Const<unreal.PRef<unreal.FVector>>, Y : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Build a reference frame from three axes
  **/
  @:ufunction(BlueprintCallable) static public function MakeRotationFromAxes(Forward : unreal.FVector, Right : unreal.FVector, Up : unreal.FVector) : unreal.FRotator;
  
  /**
    Find a rotation for an object at Start location to point at Target location.
  **/
  @:ufunction(BlueprintCallable) static public function FindLookAtRotation(Start : unreal.Const<unreal.PRef<unreal.FVector>>, Target : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FRotator;
  
  /**
    Breaks apart a rotator into {Roll, Pitch, Yaw} angles in degrees
  **/
  @:ufunction(BlueprintCallable) static public function BreakRotator(InRot : unreal.FRotator, Roll : unreal.Float32, Pitch : unreal.Float32, Yaw : unreal.Float32) : Void;
  
  /**
    Breaks apart a rotator into its component axes
  **/
  @:ufunction(BlueprintCallable) static public function BreakRotIntoAxes(InRot : unreal.Const<unreal.PRef<unreal.FRotator>>, X : unreal.PRef<unreal.FVector>, Y : unreal.PRef<unreal.FVector>, Z : unreal.PRef<unreal.FVector>) : Void;
  
  /**
    Returns true if rotator A is equal to rotator B (A == B) within a specified error tolerance
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_RotatorRotator(A : unreal.FRotator, B : unreal.FRotator, ErrorTolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Returns true if rotator A is not equal to rotator B (A != B) within a specified error tolerance
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_RotatorRotator(A : unreal.FRotator, B : unreal.FRotator, ErrorTolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Returns rotator representing rotator A scaled by B
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_RotatorFloat(A : unreal.FRotator, B : unreal.Float32) : unreal.FRotator;
  
  /**
    Returns rotator representing rotator A scaled by B
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_RotatorInt(A : unreal.FRotator, B : unreal.Int32) : unreal.FRotator;
  
  /**
    Combine 2 rotations to give you the resulting rotation of first applying A, then B.
  **/
  @:ufunction(BlueprintCallable) static public function ComposeRotators(A : unreal.FRotator, B : unreal.FRotator) : unreal.FRotator;
  
  /**
    Negate a rotator
  **/
  @:ufunction(BlueprintCallable) static public function NegateRotator(A : unreal.FRotator) : unreal.FRotator;
  
  /**
    Rotate the world forward vector by the given rotation
  **/
  @:ufunction(BlueprintCallable) static public function GetForwardVector(InRot : unreal.FRotator) : unreal.FVector;
  
  /**
    Rotate the world right vector by the given rotation
  **/
  @:ufunction(BlueprintCallable) static public function GetRightVector(InRot : unreal.FRotator) : unreal.FVector;
  
  /**
    Rotate the world up vector by the given rotation
  **/
  @:ufunction(BlueprintCallable) static public function GetUpVector(InRot : unreal.FRotator) : unreal.FVector;
  
  /**
    Get the X direction vector after this rotation
  **/
  @:ufunction(BlueprintCallable) static public function Conv_RotatorToVector(InRot : unreal.FRotator) : unreal.FVector;
  
  /**
    Convert Rotator to Transform
  **/
  @:ufunction(BlueprintCallable) static public function Conv_RotatorToTransform(InRotator : unreal.Const<unreal.PRef<unreal.FRotator>>) : unreal.FTransform;
  
  /**
    Get the reference frame direction vectors (axes) described by this rotation
  **/
  @:ufunction(BlueprintCallable) static public function GetAxes(A : unreal.FRotator, X : unreal.PRef<unreal.FVector>, Y : unreal.PRef<unreal.FVector>, Z : unreal.PRef<unreal.FVector>) : Void;
  
  /**
    Generates a random rotation, with optional random roll.
  **/
  @:ufunction(BlueprintCallable) static public function RandomRotator(bRoll : Bool = false) : unreal.FRotator;
  
  /**
    Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)
  **/
  @:ufunction(BlueprintCallable) static public function RLerp(A : unreal.FRotator, B : unreal.FRotator, Alpha : unreal.Float32, bShortestPath : Bool) : unreal.FRotator;
  
  /**
    Easing between A and B using a specified easing function
  **/
  @:ufunction(BlueprintCallable) static public function REase(A : unreal.FRotator, B : unreal.FRotator, Alpha : unreal.Float32, bShortestPath : Bool, EasingFunc : unreal.EEasingFunc, BlendExp : unreal.Float32 = 2.000000, Steps : unreal.Int32 = 2) : unreal.FRotator;
  
  /**
    Normalized A-B
  **/
  @:ufunction(BlueprintCallable) static public function NormalizedDeltaRotator(A : unreal.FRotator, B : unreal.FRotator) : unreal.FRotator;
  
  /**
    Clamps an angle to the range of [0, 360].
    
    @param Angle The angle to clamp.
    @return The clamped angle.
  **/
  @:ufunction(BlueprintCallable) static public function ClampAxis(Angle : unreal.Float32) : unreal.Float32;
  
  /**
    Clamps an angle to the range of [-180, 180].
    
    @param Angle The Angle to clamp.
    @return The clamped angle.
  **/
  @:ufunction(BlueprintCallable) static public function NormalizeAxis(Angle : unreal.Float32) : unreal.Float32;
  
  /**
    Convert a Matrix to a Transform
  **/
  @:ufunction(BlueprintCallable) static public function Conv_MatrixToTransform(InMatrix : unreal.Const<unreal.PRef<unreal.FMatrix>>) : unreal.FTransform;
  
  /**
    Convert a Matrix to a Rotator
  **/
  @:ufunction(BlueprintCallable) static public function Conv_MatrixToRotator(InMatrix : unreal.Const<unreal.PRef<unreal.FMatrix>>) : unreal.FRotator;
  
  /**
    Get the origin of the co-ordinate system
    
    @return co-ordinate system origin
  **/
  @:ufunction(BlueprintCallable) static public function Matrix_GetOrigin(InMatrix : unreal.Const<unreal.PRef<unreal.FMatrix>>) : unreal.FVector;
  
  /**
    Identity quaternion constant
  **/
  @:ufunction(BlueprintCallable) static public function Quat_Identity() : unreal.FQuat;
  
  /**
    Returns true if Quaternion A is equal to Quaternion B (A == B) within a specified error tolerance
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_QuatQuat(A : unreal.Const<unreal.PRef<unreal.FQuat>>, B : unreal.Const<unreal.PRef<unreal.FQuat>>, Tolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Returns true if Quat A is not equal to Quat B (A != B) within a specified error tolerance
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_QuatQuat(A : unreal.Const<unreal.PRef<unreal.FQuat>>, B : unreal.Const<unreal.PRef<unreal.FQuat>>, ErrorTolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Returns addition of Vector A and Vector B (A + B)
  **/
  @:ufunction(BlueprintCallable) static public function Add_QuatQuat(A : unreal.Const<unreal.PRef<unreal.FQuat>>, B : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.FQuat;
  
  /**
    Returns subtraction of Vector B from Vector A (A - B)
  **/
  @:ufunction(BlueprintCallable) static public function Subtract_QuatQuat(A : unreal.Const<unreal.PRef<unreal.FQuat>>, B : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.FQuat;
  
  /**
    Gets the result of multiplying two quaternions (A * B).
    
    Order matters when composing quaternions: C = A * B will yield a quaternion C that logically
    first applies B then A to any subsequent transformation (right first, then left).
    
    @param B The Quaternion to multiply by.
    @return The result of multiplication (A * B).
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_QuatQuat(A : unreal.Const<unreal.PRef<unreal.FQuat>>, B : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.FQuat;
  
  /**
    Checks whether this Quaternion is an Identity Quaternion.
    Assumes Quaternion tested is normalized.
    
    @param Tolerance Error tolerance for comparison with Identity Quaternion.
    @return true if Quaternion is a normalized Identity Quaternion.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_IsIdentity(Q : unreal.Const<unreal.PRef<unreal.FQuat>>, Tolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Return true if this quaternion is normalized
  **/
  @:ufunction(BlueprintCallable) static public function Quat_IsNormalized(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : Bool;
  
  /**
    Determine if all the values  are finite (not NaN nor Inf) in this Quat.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_IsFinite(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : Bool;
  
  /**
    Determine if there are any non-finite values (NaN or Inf) in this Quat.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_IsNonFinite(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : Bool;
  
  /**
    Find the angular distance/difference between two rotation quaternions.
    
    @param B Quaternion to find angle distance to
    @return angular distance in radians
  **/
  @:ufunction(BlueprintCallable) static public function Quat_AngularDistance(A : unreal.Const<unreal.PRef<unreal.FQuat>>, B : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.Float32;
  
  /**
    Modify the quaternion to ensure that the delta between it and B represents the shortest possible rotation angle.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_EnforceShortestArcWith(A : unreal.PRef<unreal.FQuat>, B : unreal.Const<unreal.PRef<unreal.FQuat>>) : Void;
  
  /**
    Convert a Quaternion into floating-point Euler angles (in degrees).
  **/
  @:ufunction(BlueprintCallable) static public function Quat_Euler(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.FVector;
  
  /**
    Used in combination with Log().
    Assumes a quaternion with W=0 and V=theta*v (where |v| = 1).
    Exp(q) = (sin(theta)*v, cos(theta))
  **/
  @:ufunction(BlueprintCallable) static public function Quat_Exp(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.FQuat;
  
  /**
    Get the angle of this quaternion
  **/
  @:ufunction(BlueprintCallable) static public function Quat_GetAngle(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.Float32;
  
  /**
    Get the forward direction (X axis) after it has been rotated by this Quaternion.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_GetAxisX(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.FVector;
  
  /**
    Get the right direction (Y axis) after it has been rotated by this Quaternion.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_GetAxisY(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.FVector;
  
  /**
    Get the up direction (Z axis) after it has been rotated by this Quaternion.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_GetAxisZ(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.FVector;
  
  /**
    Get the forward direction (X axis) after it has been rotated by this Quaternion.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_VectorForward(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.FVector;
  
  /**
    Get the right direction (Y axis) after it has been rotated by this Quaternion.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_VectorRight(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.FVector;
  
  /**
    Get the up direction (Z axis) after it has been rotated by this Quaternion.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_VectorUp(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.FVector;
  
  /**
    Normalize this quaternion if it is large enough as compared to the supplied tolerance.
    If it is too small then set it to the identity quaternion.
    
    @param Tolerance Minimum squared length of quaternion for normalization.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_Normalize(Q : unreal.PRef<unreal.FQuat>, Tolerance : unreal.Float32 = 0.000100) : Void;
  
  /**
    Get a normalized copy of this quaternion.
    If it is too small, returns an identity quaternion.
    
    @param Tolerance Minimum squared length of quaternion for normalization.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_Normalized(Q : unreal.Const<unreal.PRef<unreal.FQuat>>, Tolerance : unreal.Float32 = 0.000100) : unreal.FQuat;
  
  /**
    Get the axis of rotation of the Quaternion.
    This is the axis around which rotation occurs to transform the canonical coordinate system to the target orientation.
    For the identity Quaternion which has no such rotation, FVector(1,0,0) is returned.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_GetRotationAxis(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.FVector;
  
  /**
    Return an inversed copy of this quaternion.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_Inversed(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.FQuat;
  
  /**
    Quaternion with W=0 and V=theta*v. Used in combination with Exp().
  **/
  @:ufunction(BlueprintCallable) static public function Quat_Log(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.FQuat;
  
  /**
    Set X, Y, Z, W components of Quaternion.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_SetComponents(Q : unreal.PRef<unreal.FQuat>, X : unreal.Float32, Y : unreal.Float32, Z : unreal.Float32, W : unreal.Float32) : Void;
  
  /**
    Convert a vector of floating-point Euler angles (in degrees) into a Quaternion.
    
    @param Q Quaternion to update
    @param Euler the Euler angles
  **/
  @:ufunction(BlueprintCallable) static public function Quat_SetFromEuler(Q : unreal.PRef<unreal.FQuat>, Euler : unreal.Const<unreal.PRef<unreal.FVector>>) : Void;
  
  /**
    Convert a vector of floating-point Euler angles (in degrees) into a Quaternion.
    
    @param Euler the Euler angles
    @return constructed Quat
  **/
  @:ufunction(BlueprintCallable) static public function Quat_MakeFromEuler(Euler : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FQuat;
  
  /**
    Convert to Rotator representation of this Quaternion.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_Rotator(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.FRotator;
  
  /**
    Get the length of the quaternion.
    
    @return The length of the quaternion.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_Size(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.Float32;
  
  /**
    Get the squared length of the quaternion.
    
    @return The squared length of the quaternion.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_SizeSquared(Q : unreal.Const<unreal.PRef<unreal.FQuat>>) : unreal.Float32;
  
  /**
    Rotate a vector by this quaternion.
    
    @param V the vector to be rotated
    @return vector after rotation
  **/
  @:ufunction(BlueprintCallable) static public function Quat_RotateVector(Q : unreal.Const<unreal.PRef<unreal.FQuat>>, V : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FVector;
  
  /**
    Rotate a vector by the inverse of this quaternion.
    
    @param V the vector to be rotated
    @return vector after rotation by the inverse of this quaternion.
  **/
  @:ufunction(BlueprintCallable) static public function Quat_UnrotateVector(Q : unreal.Const<unreal.PRef<unreal.FQuat>>, V : unreal.Const<unreal.PRef<unreal.FVector>>) : unreal.FVector;
  
  /**
    White linear color
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_White() : unreal.FLinearColor;
  
  /**
    Grey linear color
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_Gray() : unreal.FLinearColor;
  
  /**
    Black linear color
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_Black() : unreal.FLinearColor;
  
  /**
    Red linear color
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_Red() : unreal.FLinearColor;
  
  /**
    Green linear color
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_Green() : unreal.FLinearColor;
  
  /**
    Blue linear color
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_Blue() : unreal.FLinearColor;
  
  /**
    Yellow linear color
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_Yellow() : unreal.FLinearColor;
  
  /**
    Transparent linear color - black with 0 opacity/alpha
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_Transparent() : unreal.FLinearColor;
  
  /**
    Make a color from individual color components (RGB space)
  **/
  @:ufunction(BlueprintCallable) static public function MakeColor(R : unreal.Float32, G : unreal.Float32, B : unreal.Float32, A : unreal.Float32 = 1.000000) : unreal.FLinearColor;
  
  /**
    Breaks apart a color into individual RGB components (as well as alpha)
  **/
  @:ufunction(BlueprintCallable) static public function BreakColor(InColor : unreal.FLinearColor, R : unreal.Float32, G : unreal.Float32, B : unreal.Float32, A : unreal.Float32) : Void;
  
  /**
    Assign contents of InColor
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_Set(InOutColor : unreal.PRef<unreal.FLinearColor>, InColor : unreal.FLinearColor) : Void;
  
  /**
    Assign individual linear RGBA components.
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_SetRGBA(InOutColor : unreal.PRef<unreal.FLinearColor>, R : unreal.Float32, G : unreal.Float32, B : unreal.Float32, A : unreal.Float32 = 1.000000) : Void;
  
  /**
    Assigns an HSV color to a linear space RGB color
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_SetFromHSV(InOutColor : unreal.PRef<unreal.FLinearColor>, H : unreal.Float32, S : unreal.Float32, V : unreal.Float32, A : unreal.Float32 = 1.000000) : Void;
  
  /**
    Assigns an FColor coming from an observed sRGB output, into a linear color.
    @param InSRGB The sRGB color that needs to be converted into linear space.
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_SetFromSRGB(InOutColor : unreal.PRef<unreal.FLinearColor>, InSRGB : unreal.Const<unreal.PRef<unreal.FColor>>) : Void;
  
  /**
    Assigns an FColor coming from an observed Pow(1/2.2) output, into a linear color.
    @param InColor The Pow(1/2.2) color that needs to be converted into linear space.
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_SetFromPow22(InOutColor : unreal.PRef<unreal.FLinearColor>, InColor : unreal.Const<unreal.PRef<unreal.FColor>>) : Void;
  
  /**
    Converts temperature in Kelvins of a black body radiator to RGB chromaticity.
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_SetTemperature(InOutColor : unreal.PRef<unreal.FLinearColor>, InTemperature : unreal.Float32) : Void;
  
  /**
    Sets to a random color. Choses a quite nice color based on a random hue.
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_SetRandomHue(InOutColor : unreal.PRef<unreal.FLinearColor>) : Void;
  
  /**
    Convert a float into a LinearColor, where each element is that float
  **/
  @:ufunction(BlueprintCallable) static public function Conv_FloatToLinearColor(InFloat : unreal.Float32) : unreal.FLinearColor;
  
  /**
    Make a color from individual color components (HSV space; Hue is [0..360) while Saturation and Value are 0..1)
  **/
  @:ufunction(BlueprintCallable) static public function HSVToRGB(H : unreal.Float32, S : unreal.Float32, V : unreal.Float32, A : unreal.Float32 = 1.000000) : unreal.FLinearColor;
  
  /**
    Converts a HSV linear color (where H is in R (0..360), S is in G (0..1), and V is in B (0..1)) to RGB
  **/
  @:ufunction(BlueprintCallable) static public function HSVToRGB_Vector(HSV : unreal.FLinearColor, RGB : unreal.PRef<unreal.FLinearColor>) : Void;
  
  /**
    Converts a HSV linear color (where H is in R, S is in G, and V is in B) to linear RGB
  **/
  @:ufunction(BlueprintCallable) static public function HSVToRGBLinear(HSV : unreal.FLinearColor) : unreal.FLinearColor;
  
  /**
    Breaks apart a color into individual HSV components (as well as alpha) (Hue is [0..360) while Saturation and Value are 0..1)
  **/
  @:ufunction(BlueprintCallable) static public function RGBToHSV(InColor : unreal.FLinearColor, H : unreal.Float32, S : unreal.Float32, V : unreal.Float32, A : unreal.Float32) : Void;
  
  /**
    Converts a RGB linear color to HSV (where H is in R (0..360), S is in G (0..1), and V is in B (0..1))
  **/
  @:ufunction(BlueprintCallable) static public function RGBToHSV_Vector(RGB : unreal.FLinearColor, HSV : unreal.PRef<unreal.FLinearColor>) : Void;
  
  /**
    Converts a RGB linear color to HSV (where H is in R, S is in G, and V is in B)
  **/
  @:ufunction(BlueprintCallable) static public function RGBLinearToHSV(RGB : unreal.FLinearColor) : unreal.FLinearColor;
  
  /**
    Converts a LinearColor to a vector
  **/
  @:ufunction(BlueprintCallable) static public function Conv_LinearColorToVector(InLinearColor : unreal.FLinearColor) : unreal.FVector;
  
  /**
    Convert from linear to 8-bit RGBE as outlined in Gregory Ward's Real Pixels article, Graphics Gems II, page 80.
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_ToRGBE(InLinearColor : unreal.FLinearColor) : unreal.FColor;
  
  /**
    Quantizes the linear color and returns the result as a FColor with optional sRGB conversion and quality as goal.
  **/
  @:ufunction(BlueprintCallable) static public function Conv_LinearColorToColor(InLinearColor : unreal.FLinearColor, InUseSRGB : Bool = true) : unreal.FColor;
  
  /**
    Quantizes the linear color and returns the result as an 8-bit color.  This bypasses the SRGB conversion.
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_Quantize(InColor : unreal.FLinearColor) : unreal.FColor;
  
  /**
    Quantizes the linear color with rounding and returns the result as an 8-bit color.  This bypasses the SRGB conversion.
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_QuantizeRound(InColor : unreal.FLinearColor) : unreal.FColor;
  
  /**
    Returns a desaturated color, with 0 meaning no desaturation and 1 == full desaturation
    
    @param       Desaturation    Desaturation factor in range [0..1]
    @return      Desaturated color
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_Desaturated(InColor : unreal.FLinearColor, InDesaturation : unreal.Float32) : unreal.FLinearColor;
  
  /**
    Euclidean distance between two color points.
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_Distance(C1 : unreal.FLinearColor, C2 : unreal.FLinearColor) : unreal.Float32;
  
  /**
    Returns a copy of this color using the specified opacity/alpha.
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_ToNewOpacity(InColor : unreal.FLinearColor, InOpacity : unreal.Float32) : unreal.FLinearColor;
  
  /**
    Returns the perceived brightness of a color on a display taking into account the impact on the human eye per color channel: green > red > blue.
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_GetLuminance(InColor : unreal.FLinearColor) : unreal.Float32;
  
  /**
    Returns the maximum color channel value in this color structure
    
    @return The maximum color channel value
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_GetMax(InColor : unreal.FLinearColor) : unreal.Float32;
  
  /**
    Returns the minimum color channel value in this color structure
    
    @return The minimum color channel value
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_GetMin(InColor : unreal.FLinearColor) : unreal.Float32;
  
  /**
    Interpolate Linear Color from Current to Target. Scaled by distance to Target, so it has a strong start speed and ease out.
    
    @param               Current                 Current Color
    @param               Target                  Target Color
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated Color
  **/
  @:ufunction(BlueprintCallable) static public function CInterpTo(Current : unreal.FLinearColor, Target : unreal.FLinearColor, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FLinearColor;
  
  /**
    Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)
  **/
  @:ufunction(BlueprintCallable) static public function LinearColorLerp(A : unreal.FLinearColor, B : unreal.FLinearColor, Alpha : unreal.Float32) : unreal.FLinearColor;
  
  /**
    Linearly interpolates between two colors by the specified Alpha amount (100% of A when Alpha=0 and 100% of B when Alpha=1).  The interpolation is performed in HSV color space taking the shortest path to the new color's hue.  This can give better results than a normal lerp, but is much more expensive.  The incoming colors are in RGB space, and the output color will be RGB.  The alpha value will also be interpolated.
    
    @param       A               The color and alpha to interpolate from as linear RGBA
    @param       B               The color and alpha to interpolate to as linear RGBA
    @param       Alpha   Scalar interpolation amount (usually between 0.0 and 1.0 inclusive)
    
    @return      The interpolated color in linear RGB space along with the interpolated alpha value
  **/
  @:ufunction(BlueprintCallable) static public function LinearColorLerpUsingHSV(A : unreal.FLinearColor, B : unreal.FLinearColor, Alpha : unreal.Float32) : unreal.FLinearColor;
  
  /**
    Returns true if linear color A is equal to linear color B (A == B) within a specified error tolerance
  **/
  @:ufunction(BlueprintCallable) static public function LinearColor_IsNearEqual(A : unreal.FLinearColor, B : unreal.FLinearColor, Tolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Returns true if linear color A is equal to linear color B (A == B) within a specified error tolerance
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_LinearColorLinearColor(A : unreal.FLinearColor, B : unreal.FLinearColor) : Bool;
  
  /**
    Returns true if linear color A is not equal to linear color B (A != B) within a specified error tolerance
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_LinearColorLinearColor(A : unreal.FLinearColor, B : unreal.FLinearColor) : Bool;
  
  /**
    Element-wise addition of two linear colors (R+R, G+G, B+B, A+A)
  **/
  @:ufunction(BlueprintCallable) static public function Add_LinearColorLinearColor(A : unreal.FLinearColor, B : unreal.FLinearColor) : unreal.FLinearColor;
  
  /**
    Element-wise subtraction of two linear colors (R-R, G-G, B-B, A-A)
  **/
  @:ufunction(BlueprintCallable) static public function Subtract_LinearColorLinearColor(A : unreal.FLinearColor, B : unreal.FLinearColor) : unreal.FLinearColor;
  
  /**
    Element-wise multiplication of two linear colors (R*R, G*G, B*B, A*A)
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_LinearColorLinearColor(A : unreal.FLinearColor, B : unreal.FLinearColor) : unreal.FLinearColor;
  
  /**
    Element-wise multiplication of a linear color by a float (F*R, F*G, F*B, F*A)
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_LinearColorFloat(A : unreal.FLinearColor, B : unreal.Float32) : unreal.FLinearColor;
  
  /**
    Element-wise multiplication of two linear colors (R/R, G/G, B/B, A/A)
  **/
  @:ufunction(BlueprintCallable) static public function Divide_LinearColorLinearColor(A : unreal.FLinearColor, B : unreal.FLinearColor) : unreal.FLinearColor;
  
  /**
    Creates a plane with a facing direction of Normal at the given Point
    
    @param Point  A point on the plane
    @param Normal  The Normal of the plane at Point
    @return Plane instance
  **/
  @:ufunction(BlueprintCallable) static public function MakePlaneFromPointAndNormal(Point : unreal.FVector, Normal : unreal.FVector) : unreal.FPlane;
  
  /**
    Makes a DateTime struct
  **/
  @:ufunction(BlueprintCallable) static public function MakeDateTime(Year : unreal.Int32, Month : unreal.Int32, Day : unreal.Int32, Hour : unreal.Int32 = 0, Minute : unreal.Int32 = 0, Second : unreal.Int32 = 0, Millisecond : unreal.Int32 = 0) : unreal.FDateTime;
  
  /**
    Breaks a DateTime into its components
  **/
  @:ufunction(BlueprintCallable) static public function BreakDateTime(InDateTime : unreal.FDateTime, Year : unreal.Int32, Month : unreal.Int32, Day : unreal.Int32, Hour : unreal.Int32, Minute : unreal.Int32, Second : unreal.Int32, Millisecond : unreal.Int32) : Void;
  
  /**
    Addition (A + B)
  **/
  @:ufunction(BlueprintCallable) static public function Add_DateTimeTimespan(A : unreal.FDateTime, B : unreal.FTimespan) : unreal.FDateTime;
  
  /**
    Subtraction (A - B)
  **/
  @:ufunction(BlueprintCallable) static public function Subtract_DateTimeTimespan(A : unreal.FDateTime, B : unreal.FTimespan) : unreal.FDateTime;
  
  /**
    Subtraction (A - B)
  **/
  @:ufunction(BlueprintCallable) static public function Subtract_DateTimeDateTime(A : unreal.FDateTime, B : unreal.FDateTime) : unreal.FTimespan;
  
  /**
    Returns true if the values are equal (A == B)
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_DateTimeDateTime(A : unreal.FDateTime, B : unreal.FDateTime) : Bool;
  
  /**
    Returns true if the values are not equal (A != B)
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_DateTimeDateTime(A : unreal.FDateTime, B : unreal.FDateTime) : Bool;
  
  /**
    Returns true if A is greater than B (A > B)
  **/
  @:ufunction(BlueprintCallable) static public function Greater_DateTimeDateTime(A : unreal.FDateTime, B : unreal.FDateTime) : Bool;
  
  /**
    Returns true if A is greater than or equal to B (A >= B)
  **/
  @:ufunction(BlueprintCallable) static public function GreaterEqual_DateTimeDateTime(A : unreal.FDateTime, B : unreal.FDateTime) : Bool;
  
  /**
    Returns true if A is less than B (A < B)
  **/
  @:ufunction(BlueprintCallable) static public function Less_DateTimeDateTime(A : unreal.FDateTime, B : unreal.FDateTime) : Bool;
  
  /**
    Returns true if A is less than or equal to B (A <= B)
  **/
  @:ufunction(BlueprintCallable) static public function LessEqual_DateTimeDateTime(A : unreal.FDateTime, B : unreal.FDateTime) : Bool;
  
  /**
    Returns the date component of A
  **/
  @:ufunction(BlueprintCallable) static public function GetDate(A : unreal.FDateTime) : unreal.FDateTime;
  
  /**
    Returns the day component of A (1 to 31)
  **/
  @:ufunction(BlueprintCallable) static public function GetDay(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the day of year of A
  **/
  @:ufunction(BlueprintCallable) static public function GetDayOfYear(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the hour component of A (24h format)
  **/
  @:ufunction(BlueprintCallable) static public function GetHour(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the hour component of A (12h format)
  **/
  @:ufunction(BlueprintCallable) static public function GetHour12(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the millisecond component of A
  **/
  @:ufunction(BlueprintCallable) static public function GetMillisecond(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the minute component of A
  **/
  @:ufunction(BlueprintCallable) static public function GetMinute(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the month component of A
  **/
  @:ufunction(BlueprintCallable) static public function GetMonth(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the second component of A
  **/
  @:ufunction(BlueprintCallable) static public function GetSecond(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns the time elapsed since midnight of A
  **/
  @:ufunction(BlueprintCallable) static public function GetTimeOfDay(A : unreal.FDateTime) : unreal.FTimespan;
  
  /**
    Returns the year component of A
  **/
  @:ufunction(BlueprintCallable) static public function GetYear(A : unreal.FDateTime) : unreal.Int32;
  
  /**
    Returns whether A's time is in the afternoon
  **/
  @:ufunction(BlueprintCallable) static public function IsAfternoon(A : unreal.FDateTime) : Bool;
  
  /**
    Returns whether A's time is in the morning
  **/
  @:ufunction(BlueprintCallable) static public function IsMorning(A : unreal.FDateTime) : Bool;
  
  /**
    Returns the number of days in the given year and month
  **/
  @:ufunction(BlueprintCallable) static public function DaysInMonth(Year : unreal.Int32, Month : unreal.Int32) : unreal.Int32;
  
  /**
    Returns the number of days in the given year
  **/
  @:ufunction(BlueprintCallable) static public function DaysInYear(Year : unreal.Int32) : unreal.Int32;
  
  /**
    Returns whether given year is a leap year
  **/
  @:ufunction(BlueprintCallable) static public function IsLeapYear(Year : unreal.Int32) : Bool;
  
  /**
    Returns the maximum date and time value
  **/
  @:ufunction(BlueprintCallable) static public function DateTimeMaxValue() : unreal.FDateTime;
  
  /**
    Returns the minimum date and time value
  **/
  @:ufunction(BlueprintCallable) static public function DateTimeMinValue() : unreal.FDateTime;
  
  /**
    Returns the local date and time on this computer
  **/
  @:ufunction(BlueprintCallable) static public function Now() : unreal.FDateTime;
  
  /**
    Returns the local date on this computer
  **/
  @:ufunction(BlueprintCallable) static public function Today() : unreal.FDateTime;
  
  /**
    Returns the UTC date and time on this computer
  **/
  @:ufunction(BlueprintCallable) static public function UtcNow() : unreal.FDateTime;
  
  /**
    Converts a date string in ISO-8601 format to a DateTime object
  **/
  @:ufunction(BlueprintCallable) static public function DateTimeFromIsoString(IsoString : unreal.FString, Result : unreal.PRef<unreal.FDateTime>) : Bool;
  
  /**
    Converts a date string to a DateTime object
  **/
  @:ufunction(BlueprintCallable) static public function DateTimeFromString(DateTimeString : unreal.FString, Result : unreal.PRef<unreal.FDateTime>) : Bool;
  
  /**
    Returns the maximum time span value
  **/
  @:ufunction(BlueprintCallable) static public function TimespanMaxValue() : unreal.FTimespan;
  
  /**
    Returns the minimum time span value
  **/
  @:ufunction(BlueprintCallable) static public function TimespanMinValue() : unreal.FTimespan;
  
  /**
    Returns a zero time span value
  **/
  @:ufunction(BlueprintCallable) static public function TimespanZeroValue() : unreal.FTimespan;
  
  /**
    Makes a Timespan struct
  **/
  @:ufunction(BlueprintCallable) static public function MakeTimespan(Days : unreal.Int32, Hours : unreal.Int32, Minutes : unreal.Int32, Seconds : unreal.Int32, Milliseconds : unreal.Int32) : unreal.FTimespan;
  
  /**
    Makes a Timespan struct
  **/
  @:ufunction(BlueprintCallable) static public function MakeTimespan2(Days : unreal.Int32, Hours : unreal.Int32, Minutes : unreal.Int32, Seconds : unreal.Int32, FractionNano : unreal.Int32) : unreal.FTimespan;
  
  /**
    Breaks a Timespan into its components
  **/
  @:ufunction(BlueprintCallable) static public function BreakTimespan(InTimespan : unreal.FTimespan, Days : unreal.Int32, Hours : unreal.Int32, Minutes : unreal.Int32, Seconds : unreal.Int32, Milliseconds : unreal.Int32) : Void;
  
  /**
    Breaks a Timespan into its components
  **/
  @:ufunction(BlueprintCallable) static public function BreakTimespan2(InTimespan : unreal.FTimespan, Days : unreal.Int32, Hours : unreal.Int32, Minutes : unreal.Int32, Seconds : unreal.Int32, FractionNano : unreal.Int32) : Void;
  
  /**
    Addition (A + B)
  **/
  @:ufunction(BlueprintCallable) static public function Add_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : unreal.FTimespan;
  
  /**
    Subtraction (A - B)
  **/
  @:ufunction(BlueprintCallable) static public function Subtract_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : unreal.FTimespan;
  
  /**
    Scalar multiplication (A * s)
  **/
  @:ufunction(BlueprintCallable) static public function Multiply_TimespanFloat(A : unreal.FTimespan, Scalar : unreal.Float32) : unreal.FTimespan;
  
  /**
    Scalar division (A * s)
  **/
  @:ufunction(BlueprintCallable) static public function Divide_TimespanFloat(A : unreal.FTimespan, Scalar : unreal.Float32) : unreal.FTimespan;
  
  /**
    Returns true if the values are equal (A == B)
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : Bool;
  
  /**
    Returns true if the values are not equal (A != B)
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : Bool;
  
  /**
    Returns true if A is greater than B (A > B)
  **/
  @:ufunction(BlueprintCallable) static public function Greater_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : Bool;
  
  /**
    Returns true if A is greater than or equal to B (A >= B)
  **/
  @:ufunction(BlueprintCallable) static public function GreaterEqual_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : Bool;
  
  /**
    Returns true if A is less than B (A < B)
  **/
  @:ufunction(BlueprintCallable) static public function Less_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : Bool;
  
  /**
    Returns true if A is less than or equal to B (A <= B)
  **/
  @:ufunction(BlueprintCallable) static public function LessEqual_TimespanTimespan(A : unreal.FTimespan, B : unreal.FTimespan) : Bool;
  
  /**
    Returns the days component of A
  **/
  @:ufunction(BlueprintCallable) static public function GetDays(A : unreal.FTimespan) : unreal.Int32;
  
  /**
    Returns the absolute value of A
  **/
  @:ufunction(BlueprintCallable) static public function GetDuration(A : unreal.FTimespan) : unreal.FTimespan;
  
  /**
    Returns the hours component of A
  **/
  @:ufunction(BlueprintCallable) static public function GetHours(A : unreal.FTimespan) : unreal.Int32;
  
  /**
    Returns the milliseconds component of A
  **/
  @:ufunction(BlueprintCallable) static public function GetMilliseconds(A : unreal.FTimespan) : unreal.Int32;
  
  /**
    Returns the minutes component of A
  **/
  @:ufunction(BlueprintCallable) static public function GetMinutes(A : unreal.FTimespan) : unreal.Int32;
  
  /**
    Returns the seconds component of A
  **/
  @:ufunction(BlueprintCallable) static public function GetSeconds(A : unreal.FTimespan) : unreal.Int32;
  
  /**
    Returns the total number of days in A
  **/
  @:ufunction(BlueprintCallable) static public function GetTotalDays(A : unreal.FTimespan) : unreal.Float32;
  
  /**
    Returns the total number of hours in A
  **/
  @:ufunction(BlueprintCallable) static public function GetTotalHours(A : unreal.FTimespan) : unreal.Float32;
  
  /**
    Returns the total number of milliseconds in A
  **/
  @:ufunction(BlueprintCallable) static public function GetTotalMilliseconds(A : unreal.FTimespan) : unreal.Float32;
  
  /**
    Returns the total number of minutes in A
  **/
  @:ufunction(BlueprintCallable) static public function GetTotalMinutes(A : unreal.FTimespan) : unreal.Float32;
  
  /**
    Returns the total number of seconds in A
  **/
  @:ufunction(BlueprintCallable) static public function GetTotalSeconds(A : unreal.FTimespan) : unreal.Float32;
  
  /**
    Returns a time span that represents the specified number of days
  **/
  @:ufunction(BlueprintCallable) static public function FromDays(Days : unreal.Float32) : unreal.FTimespan;
  
  /**
    Returns a time span that represents the specified number of hours
  **/
  @:ufunction(BlueprintCallable) static public function FromHours(Hours : unreal.Float32) : unreal.FTimespan;
  
  /**
    Returns a time span that represents the specified number of milliseconds
  **/
  @:ufunction(BlueprintCallable) static public function FromMilliseconds(Milliseconds : unreal.Float32) : unreal.FTimespan;
  
  /**
    Returns a time span that represents the specified number of minutes
  **/
  @:ufunction(BlueprintCallable) static public function FromMinutes(Minutes : unreal.Float32) : unreal.FTimespan;
  
  /**
    Returns a time span that represents the specified number of seconds
  **/
  @:ufunction(BlueprintCallable) static public function FromSeconds(Seconds : unreal.Float32) : unreal.FTimespan;
  
  /**
    Returns the ratio between two time spans (A / B), handles zero values
  **/
  @:ufunction(BlueprintCallable) static public function TimespanRatio(A : unreal.FTimespan, B : unreal.FTimespan) : unreal.Float32;
  
  /**
    Converts a time span string to a Timespan object
  **/
  @:ufunction(BlueprintCallable) static public function TimespanFromString(TimespanString : unreal.FString, Result : unreal.PRef<unreal.FTimespan>) : Bool;
  
  /**
    Creates a FQualifiedFrameTime out of a frame number, frame rate, and optional 0-1 clamped subframe.
  **/
  @:ufunction(BlueprintCallable) static public function MakeQualifiedFrameTime(Frame : unreal.FFrameNumber, FrameRate : unreal.FFrameRate, SubFrame : unreal.Float32 = 0.000000) : unreal.FQualifiedFrameTime;
  
  /**
    Breaks a FQualifiedFrameTime into its component parts again.
  **/
  @:ufunction(BlueprintCallable) static public function BreakQualifiedFrameTime(InFrameTime : unreal.Const<unreal.PRef<unreal.FQualifiedFrameTime>>, Frame : unreal.PRef<unreal.FFrameNumber>, FrameRate : unreal.PRef<unreal.FFrameRate>, SubFrame : unreal.Float32) : Void;
  
  /**
    Creates a FFrameRate from a Numerator and a Denominator. Enforces that the Denominator is at least one.
  **/
  @:ufunction(BlueprintCallable) static public function MakeFrameRate(Numerator : unreal.Int32, Denominator : unreal.Int32 = 1) : unreal.FFrameRate;
  
  /**
    Breaks a FFrameRate into a numerator and denominator.
  **/
  @:ufunction(BlueprintCallable) static public function BreakFrameRate(InFrameRate : unreal.Const<unreal.PRef<unreal.FFrameRate>>, Numerator : unreal.Int32, Denominator : unreal.Int32) : Void;
  
  /**
    Converts a byte to a float
  **/
  @:ufunction(BlueprintCallable) static public function Conv_ByteToFloat(InByte : unreal.UInt8) : unreal.Float32;
  
  /**
    Converts an integer to a float
  **/
  @:ufunction(BlueprintCallable) static public function Conv_IntToFloat(InInt : unreal.Int32) : unreal.Float32;
  
  /**
    Converts an integer to a 64 bit integer
  **/
  @:ufunction(BlueprintCallable) static public function Conv_IntToInt64(InInt : unreal.Int32) : unreal.Int64;
  
  /**
    Converts an integer to a byte (if the integer is too large, returns the low 8 bits)
  **/
  @:ufunction(BlueprintCallable) static public function Conv_IntToByte(InInt : unreal.Int32) : unreal.UInt8;
  
  /**
    Converts an integer to an IntVector
  **/
  @:ufunction(BlueprintCallable) static public function Conv_IntToIntVector(InInt : unreal.Int32) : unreal.FIntVector;
  
  /**
    Converts a int to a bool
  **/
  @:ufunction(BlueprintCallable) static public function Conv_IntToBool(InInt : unreal.Int32) : Bool;
  
  /**
    Converts a bool to an int
  **/
  @:ufunction(BlueprintCallable) static public function Conv_BoolToInt(InBool : Bool) : unreal.Int32;
  
  /**
    Converts a bool to a float (0.0f or 1.0f)
  **/
  @:ufunction(BlueprintCallable) static public function Conv_BoolToFloat(InBool : Bool) : unreal.Float32;
  
  /**
    Converts a bool to a byte
  **/
  @:ufunction(BlueprintCallable) static public function Conv_BoolToByte(InBool : Bool) : unreal.UInt8;
  
  /**
    Converts a byte to an integer
  **/
  @:ufunction(BlueprintCallable) static public function Conv_ByteToInt(InByte : unreal.UInt8) : unreal.Int32;
  
  /**
    Converts a color to LinearColor
  **/
  @:ufunction(BlueprintCallable) static public function Conv_ColorToLinearColor(InColor : unreal.FColor) : unreal.FLinearColor;
  
  /**
    Convert an IntVector to a vector
  **/
  @:ufunction(BlueprintCallable) static public function Conv_IntVectorToVector(InIntVector : unreal.Const<unreal.PRef<unreal.FIntVector>>) : unreal.FVector;
  
  /**
    Convert a float into a vector, where each element is that float
  **/
  @:ufunction(BlueprintCallable) static public function Conv_FloatToVector(InFloat : unreal.Float32) : unreal.FVector;
  
  /**
    Makes an FBox from Min and Max and sets IsValid to true
  **/
  @:ufunction(BlueprintCallable) static public function MakeBox(Min : unreal.FVector, Max : unreal.FVector) : unreal.FBox;
  
  /**
    Makes an FBox2D from Min and Max and sets IsValid to true
  **/
  @:ufunction(BlueprintCallable) static public function MakeBox2D(Min : unreal.FVector2D, Max : unreal.FVector2D) : unreal.FBox2D;
  
  /**
    Makes a SRand-based random number generator
  **/
  @:ufunction(BlueprintCallable) static public function MakeRandomStream(InitialSeed : unreal.Int32) : unreal.FRandomStream;
  
  /**
    Breaks apart a random number generator
  **/
  @:ufunction(BlueprintCallable) static public function BreakRandomStream(InRandomStream : unreal.Const<unreal.PRef<unreal.FRandomStream>>, InitialSeed : unreal.Int32) : Void;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  @:ufunction(BlueprintCallable) static public function SelectString(A : unreal.FString, B : unreal.FString, bPickA : Bool) : unreal.FString;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  @:ufunction(BlueprintCallable) static public function SelectInt(A : unreal.Int32, B : unreal.Int32, bPickA : Bool) : unreal.Int32;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  @:ufunction(BlueprintCallable) static public function SelectFloat(A : unreal.Float32, B : unreal.Float32, bPickA : Bool) : unreal.Float32;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  @:ufunction(BlueprintCallable) static public function SelectVector(A : unreal.FVector, B : unreal.FVector, bPickA : Bool) : unreal.FVector;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  @:ufunction(BlueprintCallable) static public function SelectRotator(A : unreal.FRotator, B : unreal.FRotator, bPickA : Bool) : unreal.FRotator;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  @:ufunction(BlueprintCallable) static public function SelectColor(A : unreal.FLinearColor, B : unreal.FLinearColor, bPickA : Bool) : unreal.FLinearColor;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  @:ufunction(BlueprintCallable) static public function SelectTransform(A : unreal.Const<unreal.PRef<unreal.FTransform>>, B : unreal.Const<unreal.PRef<unreal.FTransform>>, bPickA : Bool) : unreal.FTransform;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  @:ufunction(BlueprintCallable) static public function SelectObject(A : unreal.UObject, B : unreal.UObject, bSelectA : Bool) : unreal.UObject;
  
  /**
    If bPickA is true, A is returned, otherwise B is
  **/
  @:ufunction(BlueprintCallable) static public function SelectClass(A : unreal.UClass, B : unreal.UClass, bSelectA : Bool) : unreal.UClass;
  
  /**
    Returns true if A and B are equal (A == B)
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_ObjectObject(A : unreal.UObject, B : unreal.UObject) : Bool;
  
  /**
    Returns true if A and B are not equal (A != B)
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_ObjectObject(A : unreal.UObject, B : unreal.UObject) : Bool;
  
  /**
    Returns true if A and B are equal (A == B)
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_ClassClass(A : unreal.UClass, B : unreal.UClass) : Bool;
  
  /**
    Returns true if A and B are not equal (A != B)
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_ClassClass(A : unreal.UClass, B : unreal.UClass) : Bool;
  
  /**
    Determine if a class is a child of another class.
    
    @return      true if TestClass == ParentClass, or if TestClass is a child of ParentClass; false otherwise, or if either
                         the value for either parameter is 'None'.
  **/
  @:ufunction(BlueprintCallable) static public function ClassIsChildOf(TestClass : unreal.TSubclassOf<unreal.UObject>, ParentClass : unreal.TSubclassOf<unreal.UObject>) : Bool;
  
  /**
    Returns true if A and B are equal (A == B)
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_NameName(A : unreal.FName, B : unreal.FName) : Bool;
  
  /**
    Returns true if A and B are not equal (A != B)
  **/
  @:ufunction(BlueprintCallable) static public function NotEqual_NameName(A : unreal.FName, B : unreal.FName) : Bool;
  
  /**
    Make a transform from location, rotation and scale
  **/
  @:ufunction(BlueprintCallable) static public function MakeTransform(Location : unreal.FVector, Rotation : unreal.FRotator, @:bpopt("1,1,1") Scale : unreal.FVector) : unreal.FTransform;
  
  /**
    Breaks apart a transform into location, rotation and scale
  **/
  @:ufunction(BlueprintCallable) static public function BreakTransform(InTransform : unreal.Const<unreal.PRef<unreal.FTransform>>, Location : unreal.PRef<unreal.FVector>, Rotation : unreal.PRef<unreal.FRotator>, Scale : unreal.PRef<unreal.FVector>) : Void;
  
  /**
    Returns true if transform A is equal to transform B
  **/
  @:ufunction(BlueprintCallable) static public function EqualEqual_TransformTransform(A : unreal.Const<unreal.PRef<unreal.FTransform>>, B : unreal.Const<unreal.PRef<unreal.FTransform>>) : Bool;
  
  /**
    Returns true if transform A is nearly equal to B
    @param LocationTolerance        How close position of transforms need to be to be considered equal
    @param RotationTolerance        How close rotations of transforms need to be to be considered equal
    @param Scale3DTolerance         How close scale of transforms need to be to be considered equal
  **/
  @:ufunction(BlueprintCallable) static public function NearlyEqual_TransformTransform(A : unreal.Const<unreal.PRef<unreal.FTransform>>, B : unreal.Const<unreal.PRef<unreal.FTransform>>, LocationTolerance : unreal.Float32 = 0.000100, RotationTolerance : unreal.Float32 = 0.000100, Scale3DTolerance : unreal.Float32 = 0.000100) : Bool;
  
  /**
    Compose two transforms in order: A * B.
    
    Order matters when composing transforms:
    A * B will yield a transform that logically first applies A then B to any subsequent transformation.
    
    Example: LocalToWorld = ComposeTransforms(DeltaRotation, LocalToWorld) will change rotation in local space by DeltaRotation.
    Example: LocalToWorld = ComposeTransforms(LocalToWorld, DeltaRotation) will change rotation in world space by DeltaRotation.
    
    @return New transform: A * B
  **/
  @:ufunction(BlueprintCallable) static public function ComposeTransforms(A : unreal.Const<unreal.PRef<unreal.FTransform>>, B : unreal.Const<unreal.PRef<unreal.FTransform>>) : unreal.FTransform;
  
  /**
    Transform a position by the supplied transform.
    For example, if T was an object's transform, this would transform a position from local space to world space.
  **/
  @:ufunction(BlueprintCallable) static public function TransformLocation(T : unreal.Const<unreal.PRef<unreal.FTransform>>, Location : unreal.FVector) : unreal.FVector;
  
  /**
    Transform a direction vector by the supplied transform - will not change its length.
    For example, if T was an object's transform, this would transform a direction from local space to world space.
  **/
  @:ufunction(BlueprintCallable) static public function TransformDirection(T : unreal.Const<unreal.PRef<unreal.FTransform>>, Direction : unreal.FVector) : unreal.FVector;
  
  /**
    Transform a rotator by the supplied transform.
    For example, if T was an object's transform, this would transform a rotation from local space to world space.
  **/
  @:ufunction(BlueprintCallable) static public function TransformRotation(T : unreal.Const<unreal.PRef<unreal.FTransform>>, Rotation : unreal.FRotator) : unreal.FRotator;
  
  /**
    Transform a position by the inverse of the supplied transform.
    For example, if T was an object's transform, this would transform a position from world space to local space.
  **/
  @:ufunction(BlueprintCallable) static public function InverseTransformLocation(T : unreal.Const<unreal.PRef<unreal.FTransform>>, Location : unreal.FVector) : unreal.FVector;
  
  /**
    Transform a direction vector by the inverse of the supplied transform - will not change its length.
    For example, if T was an object's transform, this would transform a direction from world space to local space.
  **/
  @:ufunction(BlueprintCallable) static public function InverseTransformDirection(T : unreal.Const<unreal.PRef<unreal.FTransform>>, Direction : unreal.FVector) : unreal.FVector;
  
  /**
    Transform a rotator by the inverse of the supplied transform.
    For example, if T was an object's transform, this would transform a rotation from world space to local space.
  **/
  @:ufunction(BlueprintCallable) static public function InverseTransformRotation(T : unreal.Const<unreal.PRef<unreal.FTransform>>, Rotation : unreal.FRotator) : unreal.FRotator;
  
  /**
    Computes a relative transform of one transform compared to another.
    
    Example: ChildOffset = MakeRelativeTransform(Child.GetActorTransform(), Parent.GetActorTransform())
    This computes the relative transform of the Child from the Parent.
    
    @param               A                               The object's transform
    @param               RelativeTo              The transform the result is relative to (in the same space as A)
    @return              The new relative transform
  **/
  @:ufunction(BlueprintCallable) static public function MakeRelativeTransform(A : unreal.Const<unreal.PRef<unreal.FTransform>>, RelativeTo : unreal.Const<unreal.PRef<unreal.FTransform>>) : unreal.FTransform;
  @:ufunction(BlueprintCallable) static public function ConvertTransformToRelative(Transform : unreal.Const<unreal.PRef<unreal.FTransform>>, ParentTransform : unreal.Const<unreal.PRef<unreal.FTransform>>) : unreal.FTransform;
  
  /**
    Returns the inverse of the given transform T.
    
    Example: Given a LocalToWorld transform, WorldToLocal will be returned.
    
    @param       T       The transform you wish to invert
    @return      The inverse of T.
  **/
  @:ufunction(BlueprintCallable) static public function InvertTransform(T : unreal.Const<unreal.PRef<unreal.FTransform>>) : unreal.FTransform;
  
  /**
    Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1).
  **/
  @:ufunction(BlueprintCallable) static public function TLerp(A : unreal.Const<unreal.PRef<unreal.FTransform>>, B : unreal.Const<unreal.PRef<unreal.FTransform>>, Alpha : unreal.Float32, InterpMode : unreal.ELerpInterpolationMode = QuatInterp) : unreal.FTransform;
  
  /**
    Ease between A and B using a specified easing function.
  **/
  @:ufunction(BlueprintCallable) static public function TEase(A : unreal.Const<unreal.PRef<unreal.FTransform>>, B : unreal.Const<unreal.PRef<unreal.FTransform>>, Alpha : unreal.Float32, EasingFunc : unreal.EEasingFunc, BlendExp : unreal.Float32 = 2.000000, Steps : unreal.Int32 = 2) : unreal.FTransform;
  
  /**
    Tries to reach a target transform.
  **/
  @:ufunction(BlueprintCallable) static public function TInterpTo(Current : unreal.Const<unreal.PRef<unreal.FTransform>>, Target : unreal.Const<unreal.PRef<unreal.FTransform>>, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FTransform;
  
  /**
    Calculates the determinant of the transform (converts to FMatrix internally)
  **/
  @:ufunction(BlueprintCallable) static public function Transform_Determinant(Transform : unreal.Const<unreal.PRef<unreal.FTransform>>) : unreal.Float32;
  
  /**
    Tries to reach Target based on distance from Current position, giving a nice smooth feeling when tracking a position.
    
    @param               Current                 Actual position
    @param               Target                  Target position
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  @:ufunction(BlueprintCallable) static public function FInterpTo(Current : unreal.Float32, Target : unreal.Float32, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.Float32;
  
  /**
    Tries to reach Target at a constant rate.
    
    @param               Current                 Actual position
    @param               Target                  Target position
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  @:ufunction(BlueprintCallable) static public function FInterpTo_Constant(Current : unreal.Float32, Target : unreal.Float32, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.Float32;
  
  /**
    Tries to reach Target rotation based on Current rotation, giving a nice smooth feeling when rotating to Target rotation.
    
    @param               Current                 Actual rotation
    @param               Target                  Target rotation
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  @:ufunction(BlueprintCallable) static public function RInterpTo(Current : unreal.FRotator, Target : unreal.FRotator, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FRotator;
  
  /**
    Tries to reach Target rotation at a constant rate.
    
    @param               Current                 Actual rotation
    @param               Target                  Target rotation
    @param               DeltaTime               Time since last tick
    @param               InterpSpeed             Interpolation speed
    @return              New interpolated position
  **/
  @:ufunction(BlueprintCallable) static public function RInterpTo_Constant(Current : unreal.FRotator, Target : unreal.FRotator, DeltaTime : unreal.Float32, InterpSpeed : unreal.Float32) : unreal.FRotator;
  
  /**
    Uses a simple spring model to interpolate a float from Current to Target.
    
    @param Current                               Current value
    @param Target                                Target value
    @param SpringState                   Data related to spring model (velocity, error, etc..) - Create a unique variable per spring
    @param Stiffness                             How stiff the spring model is (more stiffness means more oscillation around the target value)
    @param CriticalDampingFactor How much damping to apply to the spring (0 means no damping, 1 means critically damped which means no oscillation)
    @param Mass                                  Multiplier that acts like mass on a spring
  **/
  @:ufunction(BlueprintCallable) static public function FloatSpringInterp(Current : unreal.Float32, Target : unreal.Float32, SpringState : unreal.PRef<unreal.FFloatSpringState>, Stiffness : unreal.Float32, CriticalDampingFactor : unreal.Float32, DeltaTime : unreal.Float32, Mass : unreal.Float32 = 1.000000) : unreal.Float32;
  
  /**
    Resets the state of a given spring
  **/
  @:ufunction(BlueprintCallable) static public function ResetFloatSpringState(SpringState : unreal.PRef<unreal.FFloatSpringState>) : Void;
  
  /**
    Resets the state of a given spring
  **/
  @:ufunction(BlueprintCallable) static public function ResetVectorSpringState(SpringState : unreal.PRef<unreal.FVectorSpringState>) : Void;
  
  /**
    Returns a uniformly distributed random number between 0 and Max - 1
  **/
  @:ufunction(BlueprintCallable) static public function RandomIntegerFromStream(Max : unreal.Int32, Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.Int32;
  
  /**
    Return a random integer between Min and Max (>= Min and <= Max)
  **/
  @:ufunction(BlueprintCallable) static public function RandomIntegerInRangeFromStream(Min : unreal.Int32, Max : unreal.Int32, Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.Int32;
  
  /**
    Returns a random bool
  **/
  @:ufunction(BlueprintCallable) static public function RandomBoolFromStream(Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : Bool;
  
  /**
    Returns a random float between 0 and 1
  **/
  @:ufunction(BlueprintCallable) static public function RandomFloatFromStream(Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.Float32;
  
  /**
    Generate a random number between Min and Max
  **/
  @:ufunction(BlueprintCallable) static public function RandomFloatInRangeFromStream(Min : unreal.Float32, Max : unreal.Float32, Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.Float32;
  
  /**
    Returns a random vector with length of 1.0
  **/
  @:ufunction(BlueprintCallable) static public function RandomUnitVectorFromStream(Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.FVector;
  
  /**
    Create a random rotation
  **/
  @:ufunction(BlueprintCallable) static public function RandomRotatorFromStream(bRoll : Bool, Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.FRotator;
  
  /**
    Reset a random stream
  **/
  @:ufunction(BlueprintCallable) static public function ResetRandomStream(Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : Void;
  
  /**
    Create a new random seed for a random stream
  **/
  @:ufunction(BlueprintCallable) static public function SeedRandomStream(Stream : unreal.PRef<unreal.FRandomStream>) : Void;
  
  /**
    Set the seed of a random stream to a specific number
  **/
  @:ufunction(BlueprintCallable) static public function SetRandomStreamSeed(Stream : unreal.PRef<unreal.FRandomStream>, NewSeed : unreal.Int32) : Void;
  
  /**
    Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
    @param ConeDir                                       The base "center" direction of the cone.
    @param ConeHalfAngleInRadians        The half-angle of the cone (from ConeDir to edge), in radians.
    @param Stream                                        The random stream from which to obtain the vector.
  **/
  @:ufunction(BlueprintCallable) static public function RandomUnitVectorInConeInRadiansFromStream(ConeDir : unreal.Const<unreal.PRef<unreal.FVector>>, ConeHalfAngleInRadians : unreal.Float32, Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.FVector;
  
  /**
    Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
    @param ConeDir                                       The base "center" direction of the cone.
    @param ConeHalfAngleInDegrees        The half-angle of the cone (from ConeDir to edge), in degrees.
    @param Stream                                        The random stream from which to obtain the vector.
  **/
  @:ufunction(BlueprintCallable) static public function RandomUnitVectorInConeInDegreesFromStream(ConeDir : unreal.Const<unreal.PRef<unreal.FVector>>, ConeHalfAngleInDegrees : unreal.Float32, Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.FVector;
  
  /**
    Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
    The shape of the cone can be modified according to the yaw and pitch angles.
    
    @param MaxYawInRadians        The yaw angle of the cone (from ConeDir to horizontal edge), in radians.
    @param MaxPitchInRadians      The pitch angle of the cone (from ConeDir to vertical edge), in radians.
    @param Stream                         The random stream from which to obtain the vector.
  **/
  @:ufunction(BlueprintCallable) static public function RandomUnitVectorInEllipticalConeInRadiansFromStream(ConeDir : unreal.Const<unreal.PRef<unreal.FVector>>, MaxYawInRadians : unreal.Float32, MaxPitchInRadians : unreal.Float32, Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.FVector;
  
  /**
    Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
    The shape of the cone can be modified according to the yaw and pitch angles.
    
    @param MaxYawInDegrees        The yaw angle of the cone (from ConeDir to horizontal edge), in degrees.
    @param MaxPitchInDegrees      The pitch angle of the cone (from ConeDir to vertical edge), in degrees.
    @param Stream                         The random stream from which to obtain the vector.
  **/
  @:ufunction(BlueprintCallable) static public function RandomUnitVectorInEllipticalConeInDegreesFromStream(ConeDir : unreal.Const<unreal.PRef<unreal.FVector>>, MaxYawInDegrees : unreal.Float32, MaxPitchInDegrees : unreal.Float32, Stream : unreal.Const<unreal.PRef<unreal.FRandomStream>>) : unreal.FVector;
  
  /**
    Generates a 1D Perlin noise from the given value.  Returns a continuous random value between -1.0 and 1.0.
    
    @param       Value   The input value that Perlin noise will be generated from.  This is usually a steadily incrementing time value.
    
    @return      Perlin noise in the range of -1.0 to 1.0
  **/
  @:ufunction(BlueprintCallable) static public function PerlinNoise1D(Value : unreal.Float32) : unreal.Float32;
  
  /**
    Finds the minimum area rectangle that encloses all of the points in InVerts
    Uses algorithm found in http://www.geometrictools.com/Documentation/MinimumAreaRectangle.pdf
    
    @param               InVerts - Points to enclose in the rectangle
    @outparam    OutRectCenter - Center of the enclosing rectangle
    @outparam    OutRectSideA - Vector oriented and sized to represent one edge of the enclosing rectangle, orthogonal to OutRectSideB
    @outparam    OutRectSideB - Vector oriented and sized to represent one edge of the enclosing rectangle, orthogonal to OutRectSideA
  **/
  @:ufunction(BlueprintCallable) static public function MinimumAreaRectangle(WorldContextObject : unreal.UObject, InVerts : unreal.Const<unreal.PRef<unreal.TArray<unreal.FVector>>>, SampleSurfaceNormal : unreal.Const<unreal.PRef<unreal.FVector>>, OutRectCenter : unreal.PRef<unreal.FVector>, OutRectRotation : unreal.PRef<unreal.FRotator>, OutSideLengthX : unreal.Float32, OutSideLengthY : unreal.Float32, bDebugDraw : Bool = false) : Void;
  
  /**
    Determines whether a given set of points are coplanar, with a tolerance. Any three points or less are always coplanar.
    
    @param Points - The set of points to determine coplanarity for.
    @param Tolerance - Larger numbers means more variance is allowed.
    
    @return Whether the points are relatively coplanar, based on the tolerance
  **/
  @:ufunction(BlueprintCallable) static public function PointsAreCoplanar(Points : unreal.Const<unreal.PRef<unreal.TArray<unreal.FVector>>>, Tolerance : unreal.Float32 = 0.100000) : Bool;
  
  /**
    Determines whether the given point is in a box. Includes points on the box.
    
    @param Point                 Point to test
    @param BoxOrigin             Origin of the box
    @param BoxExtent             Extents of the box (distance in each axis from origin)
    @return Whether the point is in the box.
  **/
  @:ufunction(BlueprintCallable) static public function IsPointInBox(Point : unreal.FVector, BoxOrigin : unreal.FVector, BoxExtent : unreal.FVector) : Bool;
  
  /**
    Determines whether a given point is in a box with a given transform. Includes points on the box.
    
    @param Point                          Point to test
    @param BoxWorldTransform      Component-to-World transform of the box.
    @param BoxExtent                      Extents of the box (distance in each axis from origin), in component space.
    @return Whether the point is in the box.
  **/
  @:ufunction(BlueprintCallable) static public function IsPointInBoxWithTransform(Point : unreal.FVector, BoxWorldTransform : unreal.Const<unreal.PRef<unreal.FTransform>>, BoxExtent : unreal.FVector) : Bool;
  
  /**
    Returns Slope Pitch and Roll angles in degrees based on the following information:
    
    @param        MyRightYAxis                            Right (Y) direction unit vector of Actor standing on Slope.
    @param        FloorNormal                                     Floor Normal (unit) vector.
    @param        UpVector                                        UpVector of reference frame.
    @outparam OutSlopePitchDegreeAngle    Slope Pitch angle (degrees)
    @outparam OutSlopeRollDegreeAngle             Slope Roll angle (degrees)
  **/
  @:ufunction(BlueprintCallable) static public function GetSlopeDegreeAngles(MyRightYAxis : unreal.Const<unreal.PRef<unreal.FVector>>, FloorNormal : unreal.Const<unreal.PRef<unreal.FVector>>, UpVector : unreal.Const<unreal.PRef<unreal.FVector>>, OutSlopePitchDegreeAngle : unreal.Float32, OutSlopeRollDegreeAngle : unreal.Float32) : Void;
  
  /**
    Computes the intersection point between a line and a plane.
    @param               T - The t of the intersection between the line and the plane
    @param               Intersection - The point of intersection between the line and the plane
    @return              True if the intersection test was successful.
  **/
  @:ufunction(BlueprintCallable) static public function LinePlaneIntersection(LineStart : unreal.Const<unreal.PRef<unreal.FVector>>, LineEnd : unreal.Const<unreal.PRef<unreal.FVector>>, APlane : unreal.Const<unreal.PRef<unreal.FPlane>>, T : unreal.Float32, Intersection : unreal.PRef<unreal.FVector>) : Bool;
  
  /**
    Computes the intersection point between a line and a plane.
    @param               T - The t of the intersection between the line and the plane
    @param               Intersection - The point of intersection between the line and the plane
    @return              True if the intersection test was successful.
  **/
  @:ufunction(BlueprintCallable) static public function LinePlaneIntersection_OriginNormal(LineStart : unreal.Const<unreal.PRef<unreal.FVector>>, LineEnd : unreal.Const<unreal.PRef<unreal.FVector>>, PlaneOrigin : unreal.FVector, PlaneNormal : unreal.FVector, T : unreal.Float32, Intersection : unreal.PRef<unreal.FVector>) : Bool;
  
}
