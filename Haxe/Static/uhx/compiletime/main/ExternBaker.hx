package uhx.compiletime.main;
import haxe.macro.Compiler;
import haxe.macro.Context;
import haxe.macro.Expr;
import haxe.macro.Type;
import sys.FileSystem;
import sys.io.File;
import uhx.compiletime.tools.CodeFormatter;
import uhx.compiletime.tools.HelperBuf;
import uhx.compiletime.types.GlueMethod;
import uhx.compiletime.types.TypeRef;
import uhx.compiletime.types.TypeConv;
import uhx.compiletime.tools.DepList;

using haxe.macro.Tools;
using Lambda;
using StringTools;
using uhx.compiletime.tools.MacroHelpers;

/**
  This is the first pass in the Haxe compilation pipeline. It must run as a separate
  compilation step, as it will generate actual Haxe files which will be used as the source for the next
  passes.
 **/
class ExternBaker {
  /**
    Processes the 'Externs' directories and creates Haxe wrappers based on them.
    This command should be run through `--macro` command-line option, and `--no-output` (so
    hxcpp doesn't try to build those files).
    The target directory will be the selected by `-cpp <targetdir>` command-line option

    Classpaths included here will be added with ascending priority - the last being the higher
    priority, and the first being the lower.
   **/
  public static function process(classpaths:Array<String>, targetStamp:String, targetFiles:String) {
    classpaths.reverse();
    // parse the optional arguments
    Compiler.addGlobalMetadata("", "@:build(uhx.compiletime.types.OptionalArgsBuild.build())");

    #if bake_externs
    TypeConv.onTypeLoad = function(name:String) {
      try {
        var extra = Context.getType(name + '_Extra');
        // it exists
        if (extra != null) {
          Context.getType(name);
          joinMetas(name + '_Extra', name);
        }
      }
      catch(e:Dynamic) {
      }
    };
    #end

    // walk into the paths - from last to first - and if needed, create the wrapper code
    var target = Compiler.getOutput();
    target = FileSystem.fullPath(target);
    var verbose = Context.defined('UHX_VERBOSE');
    var filesToCompile = new Map();
    {
      var file = sys.io.File.read(targetFiles);
      var ver = file.readLine();
      if (ver != 'BAKERFILES1') {
        throw 'Unknown version $ver when processing target file descriptor $targetFiles';
      }
      try {
        while(true) {
          var module = file.readLine();
          var file = module.replace('.','/') + '.hx';
          var first = true;
          var found = false;
          for (cp in classpaths) {
            var target = '$cp/$file';
            if (FileSystem.exists(target)) {
              found = true;
              if (module.endsWith('_Extra')) {
                if (joinMetas(module, target)) {
                  deps.setExtraFile(module.substr(0, module.length - '_Extra'.length));
                }
              }
              filesToCompile[target.toLowerCase()] = { module:module, file:target, localExtern:first };
              break;
            }
            first = false;
          }
          if (!found && verbose) {
            Context.warning('Extern baker: Could not find module $module. Perhaps it was deleted', Context.currentPos());
          }
        }
      } catch(e:haxe.io.Eof) {
      }
      file.close();
    }

    var hadErrors = false;

    function generatedSourceIsValid(srcFile:String, generatedFile:String, info:GeneratedInfo):Bool {
      if (info == null) {
        return true;
      }

      // if the original source file still exists, wasn't changed, and
      if (info.srcFile != srcFile.toLowerCase() && FileSystem.exists(info.srcFile) && !filesToCompile.exists(info.srcFile)) {
        Context.warning('Error: Unreal Extern Baker: A conflict was detected while generating ${generatedFile}: It was previously generated by ${info.srcFile}, ' +
            'which is unchanged, and is now generated by ${srcFile}. Please make sure that this reference is not duplicate. If you think this is an error, ' +
            'you may compile with the `disableBakerSourceCheck` configuration variable set, or delete your `{ProjectRoot}/Haxe/Generated` folder to force all files to be ' +
            'regenerated and try again', // a bug report will also be appreciated
            Context.makePosition({ file:srcFile, max:0, min:0 }));
        return false;
      }
      return true;
    }

    var modules = [];
    var unames = new Map();
    for (ref in filesToCompile) {
      var module = Context.getModule(ref.module);
      modules.push({ module:module, ref: ref });
    }

    Context.onGenerate(function(_) {
      for (m in modules) {
        var module = m.module,
            ref = m.ref;
        var generatedHeader = getGeneratedHeader({ srcFile: ref.file.toLowerCase(), ver:1 });
        var pack = ref.module.split('.'),
            name = pack.pop();

        var buf = new StringBuf();
        buf.add(generatedHeader);
        if (pack.length != 0) {
          buf.add('package ${pack.join('.')};\n');
        }
        var processor = new ExternBaker(buf);
        for (type in module) {
          var pos = null;
          var uname = switch(type) {
            case TInst(c,_):
              var c = c.get();
              if (c.meta.has(':haxeGenerated') || c.name.endsWith('_Extra')) {
                continue;
              }
              pos = c.pos;
              MacroHelpers.getUName(c);
            case TEnum(e,_):
              var e = e.get();
              if (e.meta.has(':haxeGenerated')) {
                continue;
              }
              pos = e.pos;
              MacroHelpers.getUName(e);
            case TAbstract(a,_):
              var a = a.get();
              if (a.meta.has(':haxeGenerated')) {
                continue;
              }
              pos = a.pos;
              MacroHelpers.getUName(a);
            case TType(t,_):
              // force the type to be built
              Context.follow(type);
              // reload it - to referesh its metadata
              var t = t.get();
              if (!t.meta.has(':uPrimeTypedef')) {
                continue;
              }
              pos = t.pos;
              MacroHelpers.getUName(t);
            case _:
              null;
          }
          var lastPos = uname == null ? null : unames[uname];
          if (lastPos != null) {
            Context.warning('A class or struct with the name $uname was already defined. Please delete the one of the definitions, or change their name', pos);
            Context.warning('$uname was defined here', lastPos);
            hadErrors = true;
            continue;
          }
          if (uname != null) {
            unames[uname] = pos;
          }

          var glueBuf = processor.processType(type, ref.localExtern ? null : 'Unreal'),
              glue = Std.string(glueBuf);
          hadErrors = hadErrors || processor.hadErrors;
          if (glueBuf != null && glue != '') {
            var glueType = processor.glueType;
            var dir = target + '/' + glueType.pack.join('/');

            if (!FileSystem.exists(dir)) {
              try {
                FileSystem.createDirectory(dir);
              }
              catch (e:Dynamic) {
                trace('failed when creating $dir: there might be a race condition');
              }
            }

            var targetFile = '$dir/${glueType.name}.hx';
            var info = getGeneratedInfo(targetFile);
            if (generatedSourceIsValid(ref.file, targetFile, info)) {
              var file = File.write(targetFile, false);
              file.writeString(generatedHeader);
              file.writeString(uhx.compiletime.tools.BaseWriter.prelude);
              file.writeString('package ${glueType.pack.join('.')};\n' +
                '@:unrealGlue extern class ${glueType.name} {\n');
              file.writeString(glue);
              file.writeString('}');
              file.close();
            } else {
              hadErrors = true;
            }
          }
        }
        var dir = target + '/' + pack.join('/');
        if (!FileSystem.exists(dir)) {
          try {
            FileSystem.createDirectory(dir);
          } catch(e:Dynamic) {
            trace('failed when creating $dir: there might be a race condition');
          }
        }

        var targetFile = '$dir/$name.hx';
        var info = getGeneratedInfo(targetFile);
        if (generatedSourceIsValid(ref.file, targetFile, info)) {
          File.saveContent(targetFile, buf.toString());
        } else {
          hadErrors = true;
        }
      }
      if (hadErrors) {
        throw new Error('Extern bake finished with errors',Context.currentPos());
      }
#if bake_externs
      var target = Context.definedValue("UHX_STATIC_BASE_DIR");
      deps.save(targetStamp);
#end
    });
  }

  private static var deps:DepList = new DepList();

  private static function getGeneratedInfo(generatedFile:String):Null<GeneratedInfo> {
#if NO_SOURCE_CHECK
    return null;
#else
    if (FileSystem.exists(generatedFile)) {
      var ln:String = null,
          ln2:String = null;
      try {
        var file = sys.io.File.read(generatedFile);
        ln = file.readLine();
        ln2 = file.readLine();
        file.close();
      }
      catch(e:Dynamic) {
        Context.warning('Error while reading generated file $generatedFile: $e', Context.makePosition({ file:generatedFile, max:0, min:0 }));
        return null;
      }

      if (!ln.startsWith('// Ver:')) {
        // assume it's old data
        return null;
      }
      ln = ln.substr('// Ver:'.length);
      var ver = Std.parseInt(ln);
      if (!ln2.startsWith('// GeneratedBy:')) {
        return null;
      }
      ln2 = ln2.substr('// GeneratedBy:'.length);
      return { ver:ver, srcFile:ln2.toLowerCase() };
    }
    return null;
#end
  }

  public static function getGeneratedHeader(info:GeneratedInfo):String {
    return '// Ver:${info.ver}\n// GeneratedBy:${info.srcFile}\n';
  }

  private static var joinedMetas = new Map();

  private static function joinMetas(extraModuleName:String, file:String):Bool {
    if (joinedMetas[extraModuleName]) {
      return true;
    }
#if bake_externs
    TypeConv.setTypeLoaded(extraModuleName);
    TypeConv.setTypeLoaded(extraModuleName.substr(0,extraModuleName.length - '_Extra'.length));
#end
    var pos = Context.makePosition({ min:0, max:0, file:file });
    var extraModule = getModule(extraModuleName, pos);
    if (extraModule == null || extraModule.length == 0) {
      return false;
    }
    var module = extraModule.find(function(m) return switch(m) { case TInst(_.get() => c, _): c.name.endsWith('_Extra'); case _: false; });
    if (module == null) {
      throw new Error('No `_Extra` class is defined in this module', pos);
    }

    switch(Context.follow(module)) {
    case TInst(_.get() => cextra,_):
      var moduleName = extraModuleName.substr(0,extraModuleName.length - '_Extra'.length);
      var modules = getModule(moduleName, pos);
      if (modules == null || modules.length == 0) {
        return false;
      }
      var base:BaseType = null;
      for (mod in modules) {
        base = switch(mod) {
          case TInst(cl, _):
            if (cl.toString() == moduleName) {
              cl.get();
            } else {
              null;
            }
          case TEnum(e, _):
            if (e.toString() == moduleName) {
              e.get();
            } else {
              null;
            }
          case TAbstract(a, _):
            if (a.toString() == moduleName) {
              a.get();
            } else {
              null;
            }
          case TType(t, _):
            if (t.toString() == moduleName) {
              t.get();
            } else {
              null;
            }
          case type:
            throw new Error('Unsupported type ${type.toString()} for module ${extraModuleName.substr(0,extraModuleName.length - '_Extra'.length)}', pos);
        };
        if (base != null) {
          break;
        }
      }
      if (base == null) {
        throw new Error('Type ${moduleName} is referenced by an `_Extra` type but it does not define a valid type', pos);
      }
      if (cextra.meta.has(':glueCppIncludes')) {
        base.meta.remove(':glueCppIncludes');
      }
      if (cextra.meta.has(':hasCopy')) {
        base.meta.remove(':noCopy');
      }
      if (cextra.meta.has(':hasEquals')) {
        base.meta.remove(':noEquals');
      }
      for (meta in cextra.meta.get()) {
        base.meta.add(meta.name, meta.params, meta.pos);
      }
    case _:
      throw new Error('Module $extraModuleName should be an extern class', Context.makePosition({ min:0, max:0, file:file }));
    }
    joinedMetas[extraModuleName] = true;
    return true;
  }

  private var buf:CodeFormatter;
  private var realBuf:HelperBuf;
  private var glue:CodeFormatter;
  private var glueType:TypeRef;
  private var thisConv:TypeConv;
  private var cls:ClassType;
  private var module:String;

  private var type:Type;
  private var typeRef:TypeRef;

  private var pos:Position;
  private var params:Array<String>;
  private var optionals:Map<String, Array<Expr>> = new Map();
  public var hadErrors(default, null):Bool;

  @:isVar private var voidType(get,null):Null<TypeConv>;

  public function new(buf:StringBuf) {
    this.realBuf = buf;
    this.buf = new CodeFormatter();
    this.hadErrors = false;
    this.params = [];
  }

  public function processType(type:Type, ?defaultModule:String):CodeFormatter {
    this.type = type;
    this.glue = new CodeFormatter();
    switch(type) {
    case TInst(c,tl):
      var cls = c.get();
      var sup = cls.superClass;
      while(sup != null) {
        var cur = sup.t.get();
        if (cur.meta.has(':haxeGenerated') || cur.meta.has(':haxeSuper')) {
          cls.meta.add(':haxeSuper', [], cls.pos);
          break;
        }
        sup = cur.superClass;
      }
      if (defaultModule != null && !cls.meta.has(':umodule')) {
        cls.meta.add(':umodule', [macro $v{defaultModule}], cls.pos);
      }
      this.processClass(type, cls);
    case TEnum(e,tl):
      var e = e.get();
      if (defaultModule != null && !e.meta.has(':umodule')) {
        e.meta.add(':umodule', [macro $v{defaultModule}], e.pos);
      }
      this.processEnum(e);
    case TType(t,_):
      var t2 = Context.follow(type, true);
      switch(t2) {
      case TInst(c,tl):
        var cls = c.get();
        if (defaultModule != null && !cls.meta.has(':umodule')) {
          cls.meta.add(':umodule', [macro $v{defaultModule}], cls.pos);
        }
        this.processClass(type, cls);
      case _:
        Context.warning('Type $type is not supported',t.get().pos);
      }
    case _:
      var pos = switch(Context.follow(type)) {
      case TInst(c,tl): c.get().pos;
      case TEnum(e,tl): e.get().pos;
      case TAbstract(a,tl): a.get().pos;
      case TAnonymous(a): a.get().fields[0].pos;
      case _: return null;
      }
      this.pos = pos;
      Context.warning('Type $type is not supported',pos);
    }
    return glue;
  }

  private function processTemplatedClass(tconv:TypeConv, c:ClassType) {
    var decl = new CodeFormatter(),
        impl = new CodeFormatter();
    var cppType = tconv.ueType.getCppType().toString(),
        glueName = tconv.haxeType.getGlueHelperType().getCppType() + '_UE_obj';
    decl << 'namespace uhx {' << new Newline()
         << 'template<';
    decl.foldJoin(c.params, function(param,buf) return buf << 'class ' << param.name);
    var noUObject = Context.defined('UHX_NO_UOBJECT');
    decl << '>' << new Newline();
    decl << 'struct TTemplatedData<' << cppType << '>' << new Begin('{')
          << (noUObject ? '' : 'typedef TStructOpsTypeTraits<$cppType> TTraits;') << new Newline()
          << 'FORCEINLINE static const StructInfo *getInfo();' << new Newline()
          << 'private:' << new Newline()
          << 'static void destruct(const uhx::StructInfo *info, unreal::UIntPtr ptr)' << new Begin('{')
            << 'uhx::TDestruct<' << cppType << '>::doDestruct(ptr);'
          << new End('}')
        << new End('};')
      << '}' << new Newline();
    impl << 'template<';
    impl.foldJoin(c.params, function(param,buf) return buf << 'class ' << param.name);
    impl << '> const uhx::StructInfo *::uhx::TTemplatedData<' << cppType << '>::getInfo()' << new Begin('{')
          << 'static $glueName<';
    impl.foldJoin(c.params, function(param,buf) return buf << param.name);
    impl << '> genericImplementation;' << new Newline();
    impl << 'static const StructInfo * genericParams[${c.params.length + 1}] = { ';
    impl.foldJoin(c.params, function(param,buf) return buf << 'uhx::TAnyData< ' << param.name << ' >::getInfo()');
    impl << ', nullptr };' << new Newline();
    impl << 'static uhx::StructInfo info = ' << new Begin('{')
            << '/* .name = */ "' << tconv.ueType.name << '",' << new Newline()
            << '/* .flags = */ UHX_Templated,' << new Newline()
            << '/* .size = */ (unreal::UIntPtr) sizeof(' << cppType << '),' << new Newline()
            << '/* .alignment = */ (unreal::UIntPtr) uhx::Alignment<' << cppType << '>::get(),' << new Newline()
            << '/* .destruct = */ (${noUObject ? "" : "TTraits::WithNoDestructor || "}std::is_trivially_destructible<' << cppType << '>::value ? nullptr : &TTemplatedData<$cppType>::destruct),' << new Newline()
            << '/* .equals = */ nullptr,' << new Newline()
            << '/* .genericParams = */ genericParams,' << new Newline()
            << '/* .genericImplementation = */ &genericImplementation,' << new Newline()
            << '/* .contextObject  = */ nullptr'
          << new End('};')
          << 'return &info;'
      << new End('}');
    c.meta.add(':ueHeaderStart', [macro $v{decl.toString()}], c.pos);
    c.meta.add(':ueHeaderEnd'  , [macro $v{impl.toString()}], c.pos);
  }

  private static function getOptionals(meta:Metadata, optionals:Map<String, Array<Expr>>):Metadata {
    var ret = [];
    for (meta in meta) {
      if (meta.name.startsWith(':opt_')) {
        optionals[meta.name.substr(':opt_'.length)] = meta.params;
      } else {
        ret.push(meta);
      }
    }
    return ret;
  }

  private static function getAllDefinedSuperFields(c:ClassType, fields:Map<String, Bool>):Void {
    var sup = c.superClass;
    if (sup == null) {
      return;
    }
    var supCl = sup.t.get();
    for (field in supCl.fields.get()) {
      fields[field.name] = true;
    }
    try {
      switch(Context.getType(sup.t.toString() + '_Extra')) {
      case TInst(c,_):
        for (field in c.get().fields.get()) {
          fields[field.name] = true;
        }
      case _:
      }
    }
    catch(e:Dynamic) {
    }

    getAllDefinedSuperFields(supCl, fields);
  }

  private function processClass(type:Type, c:ClassType) {
    this.cls = c;
    this.module = c.module;
    if (c.meta.has(':uownerModule')) {
      this.module = MacroHelpers.extractStrings(c.meta, ':uownerModule')[0];
    }
    this.params = [ for (p in c.params) p.name ];
    this.pos = c.pos;
    if (!c.isExtern) return;
    this.type = type;
    this.typeRef = TypeRef.fromBaseType(c, c.pos);
    this.glueType = this.typeRef.getGlueHelperType();
    this.thisConv = TypeConv.get(type,c.pos);

    switch(this.thisConv.data) {
    case CStruct(_,_,_,params):
      if (params != null && params.length > 0) {
        processTemplatedClass(this.thisConv, c);
      }
    case _:
    }
    if (!c.meta.has(':uextern')) {
      throw new Error('Extern Baker: Extern class $typeRef is on the extern class path, but is not a @:uextern type', c.pos);
    }

    this.addDoc(c.doc);
    var fields = c.fields.get(),
        statics = c.statics.get(),
        ctor = c.constructor == null ? null : c.constructor.get(),
        meta = c.meta.get();
    meta = getOptionals(meta, this.optionals);
    // process the _Extra type if found
    var extraName = c.pack.join('.') + (c.pack.length > 0 ? '.' : '') + c.name + '_Extra';
    var extra = getModule(extraName, c.pos);
    if (extra != null && extra.length > 0) {
      var name = c.name + '_Extra';
      var module = extra.find(function(m) return switch(m) { case TInst(_.get() => c, _): c.name == name; case _: false; });
      switch(module) {
      case TInst(_.get() => ecl,_):
        getOptionals(ecl.meta.get(), this.optionals);
        var efields = ecl.fields.get();
        var estatics = ecl.statics.get();
        var ector = ecl.constructor == null ? null : ecl.constructor.get();
        if (ector != null) {
          if (ctor != null) {
            Context.warning('Unreal Extern Baker: The constructor already exists on ${c.name}', ector.pos);
          }
          ctor = ector;
        }
        for (field in efields) {
          var oldFieldIdx = -1;
          for (i in 0...fields.length) {
            if (fields[i].name == field.name) {
              oldFieldIdx = i;
              break;
            }
          }
          if (oldFieldIdx >= 0) {
            if (field.meta.has(':ureplace')) {
              fields[oldFieldIdx] = field;
            } else {
              Context.warning('Unreal Extern Baker: The field ${field.name} already exists on ${c.name}. Define it with the metadata @:ureplace to replace it', field.pos);
            }
          } else {
            fields.push(field);
          }
        }

        for (field in estatics) {
          var oldFieldIdx = -1;
          for (i in 0...statics.length) {
            if (statics[i].name == field.name) {
              oldFieldIdx = i;
              break;
            }
          }
          if (oldFieldIdx >= 0) {
            if (field.meta.has(":ureplace")) {
              statics[oldFieldIdx] = field;
            } else {
              Context.warning('Unreal Extern Baker: The field ${field.name} already exists on ${c.name}. Define it with the metadata @:ureplace to replace it', field.pos);
            }
          } else {
            statics.push(field);
          }
        }
      case _:
        var pos = switch(extra[0]) {
        case TAbstract(a,_):
          a.get().pos;
        case TEnum(e,_):
          e.get().pos;
        case TType(t,_):
          t.get().pos;
        case _:
          c.pos;
        }
        Context.warning('Unreal Extern Baker: Type ${c.name}_Extra is not a class',pos);
      }
    }

    var params = new HelperBuf();
    var isNoTemplate = c.meta.has(':noTemplate');
    if (c.params != null && c.params.length > 0 && !isNoTemplate) {
      params << '<';
      params.mapJoin(c.params, function(p) return p.name);
      params << '>';
    }
    var params = params.toString();

    this.addMeta(meta);
    if (MacroHelpers.extractStrings(c.meta, ':umodule')[0] == 'UnrealEd' || c.pack.join('.') == 'unreal.editor') {
      this.add('#if !WITH_EDITOR @:deprecated("The class ${c.name} is an editor-only class and should not be used on non-editor builds") #end');
      this.newline();
    }
    if (!c.isInterface) {
      this.add('@:ueGluePath("${this.glueType.getClassPath()}")\n');
    }
    if (c.params.length > 0 && !isNoTemplate) {
      this.add('@:ueTemplate\n');
    }
    var name = null;
    if (meta.hasMeta(':bake_externs_name_hack')) {
      name = meta.extractStringsFromMetadata(':bake_externs_name_hack')[0];
    }
    if (name == null) {
      name = typeRef.getClassPath();
    }
    this.add('#if (cppia && !LIVE_RELOAD_BUILD && !macro) @:build(uhx.compiletime.types.CompiledMetaCheck.build("${name}")) #end');
    this.newline();
    if (c.isPrivate) {
      this.add('private ');
    }

    var isAbstract = false,
        isTemplateStruct = false,
        superStruct = null;
    if (this.thisConv.data.match(CUObject(_))) {
      if (c.isInterface) {
        this.add('interface ');
      } else {
        this.add('class ');
      }
      this.add('${c.name}$params ');
      this.add('#if !macro ');
      if (c.superClass != null) {
        var supRef = TypeConv.get(TInst(c.superClass.t, c.superClass.params), pos).haxeType.toString();
        this.add('extends $supRef ');
      } else if (c.isInterface) {
        this.add('extends unreal.IInterface ');
      } else {
        this.add('implements unreal.IInterface ');
      }
      var superFields = new Map();
      getAllDefinedSuperFields(c, superFields);

      function superFilter(fields:Array<ClassField>, field:ClassField) {
        if (superFields.exists(field.name)) {
          if (!fields.exists(function(cf) return cf != field && cf.getUName() == field.name)) {
            Context.warning('Unreal Extern Baker: The field ${field.name} already exists in a superclass. Create a new field with another name and with the metadata @:uname("${field.name}")', field.pos);
          }
          return false;
        }
        return true;
      }

      fields = fields.filter(superFilter.bind(fields));
      statics = statics.filter(superFilter.bind(statics));
    } else {
      isAbstract = true;
      if (c.superClass == null) {
        this.add('@:forward(dispose,isDisposed) ');
      } else if (!isTemplateStruct && c.params.length > 0 && !isNoTemplate) {
        this.add('@:forward(getTemplateStruct) ');
      } else {
        this.add('@:forward ');
      }
      this.add('abstract ${c.name}$params');
      this.add('#if macro (Dynamic) #else (');
      if (c.superClass == null) {
        switch(c.meta.extract(':udelegate')[0]) {
        case null:
          if (c.params.length > 0 && !isNoTemplate) {
            superStruct = new TypeRef(['unreal'], 'TemplateStruct');
          } else {
            superStruct = new TypeRef(['unreal'], 'Struct');
          }
        case { params: [macro var _:$t], pos:pos }:
          superStruct = TypeRef.fromType( t.toType(), pos );
        case { params: [{ expr:ECheckType(_, t)}], pos:pos }:
          superStruct = TypeRef.fromType( t.toType(), pos );
        case { params: [{ expr:EParenthesis({ expr:ECheckType(_, t)}) }], pos:pos }:
          superStruct = TypeRef.fromType( t.toType(), pos );
        case e:
          throw new Error('Bad @:udelegate format: $e', e.pos);
        }

        this.add('$superStruct) to $superStruct ');
      } else {
        superStruct = TypeRef.fromType( TInst(c.superClass.t, c.superClass.params), c.pos );
        this.add('$superStruct) ');
      }
      var sup = c.superClass;
      while(sup != null) {
        var supRef = TInst(sup.t, sup.params).toString();
        this.add('to $supRef ');
        sup = sup.t.get().superClass;
      }
      this.add('to unreal.Struct to unreal.VariantPtr ');
    }

    for (iface in c.interfaces) {
      var t = TInst(iface.t, iface.params).toString();
      // var ifaceRef = TypeRef.fromBaseType(iface.t.get(), iface.params, c.pos);
      if (isAbstract) {
        this.add('to ');
      } else {
        if (c.isInterface)
          this.add('extends ');
        else
          this.add('implements ');
      }
      this.add('$t ');
    }
    var methods = [];
    this.add('#end ');
    this.begin('{');
    this.add('#if !macro ');
    this.newline();
      if (isAbstract && !isTemplateStruct && c.params.length > 0 && !isNoTemplate) {
        // if a templated struct extends a non-templated struct, we need to expose this
        this.add('@:extern inline private function getTemplateStruct():unreal.Wrapper.TemplateWrapper { return @:privateAccess this.getTemplateStruct(); }');
        this.newline();
      }
      if (ctor != null) {
        processField(ctor,true, methods);
      }
      for (field in statics) {
        processField(field,true, methods);
      }
      for (field in fields) {
        processField(field,false, methods);
      }

      if (this.thisConv.data.match(CUObject(_))) {
        var uname = switch(MacroHelpers.extractStrings(c.meta, ':uname')[0]) {
        case null:
          c.name;
        case name:
          name;
        };
        uname = uname.substr(1);

        // Add the className to the classMap with the wrapped as the value so we can access it in wrap().
        if (!c.isInterface && !meta.hasMeta(':global')) {
          var glueClassGet = glueType.getClassPath() + '.StaticClass()';
          if (!methods.exists(function(m) return m.uname == 'StaticClass')) {
            if (!meta.hasMeta(':noClass')) {
              methods.push({
                name:'StaticClass',
                uname:'StaticClass',
                doc:'\n\t\tReturns the `UClass` object which describes this class\n\t',
                args: [],
                meta: [{ name:':ifFeature', params:[ macro $v{'${this.thisConv.haxeType.withoutModule().getClassPath()}.*'} ], pos:c.pos }],
                ret: TypeConv.get(Context.getType("unreal.UClass"), pos),
                flags: Final | Static,
                pos: c.pos,
              });
            } else {
              glueClassGet = 'uhx.glues.UObject_Glue.StaticFindObjectFast(uhx.glues.UClass_Glue.StaticClass(), 0, new unreal.FName("${uname}"), false, true, unreal.EObjectFlags.RF_NoFlags)';
              this.add('@:ifFeature("${this.thisConv.haxeType.withoutModule().getClassPath()}.*") public static function StaticClass():unreal.UClass');
              this.begin(' {');
                this.add('return cast unreal.UObject.StaticFindObjectFast(unreal.UClass.StaticClass(), null, new unreal.FName("${uname}"), false, true, unreal.EObjectFlags.RF_NoFlags);');
              this.end('}');
            }
          }

          var hasHaxeSuper = meta.hasMeta(':haxeSuper');
          this.add('static function __init__():Void');
          this.begin(' {');
            this.add('#if !cppia');
            this.newline();
            this.add('var func = cpp.Function.fromStaticFunction(wrapPointer).toFunction();');
            this.newline();
            this.add('uhx.ue.ClassMap.${hasHaxeSuper ? "addCustomCtor" : "addWrapper"}($glueClassGet, func);');
            this.newline();
            this.add('#else');
            this.newline();
            this.add('uhx.runtime.Helpers.${hasHaxeSuper ? "addCppiaCustomCtor" : "addCppiaExternWrapper"}("${uname}", "${this.typeRef.getClassPath(true)}");');
            this.newline();
            this.add('#end');
          this.end('}');
          this.newline();

          // add wrap
          this.add('#if !cppia');
          this.newline();
          this.add('static function wrapPointer(uobject:unreal.UIntPtr):unreal.UIntPtr');
          this.begin(' {');
            this.add('return uhx.internal.HaxeHelpers.dynamicToPointer(new ${this.typeRef.getClassPath()}(uobject));');
          this.end('}');
          this.add('#end');
          this.newline();

          this.add('inline public static function wrap(uobject:${this.thisConv.haxeGlueType}):${this.typeRef.getClassPath()}');
          this.begin(' {');
            this.add('return cast uhx.ClassWrap.wrap(uobject);');
          this.end('}');
        }
      } else if (!c.isInterface) {  // non-uobject
        // add wrap for non-uobject types
        this.add('inline public static function fromPointer$params(ptr:');
        this.add(this.thisConv.haxeGlueType.toString());
        this.add('):' + this.thisConv.haxeType);
        this.begin(' {');
          this.add('return cast ptr;');
        this.end('}');

        if (c.meta.has(':ustruct') && c.params.length == 0 && !Context.defined('UHX_NO_UOBJECT')) {
          var uname = MacroHelpers.getUName(c).substr(1);
          if (!methods.exists(function(m) return m.uname == 'StaticStruct')) {
            this.add('public static function StaticStruct():unreal.UScriptStruct');
            this.begin(' {');
              this.add('return (uhx_structData != null ? uhx_structData : (uhx_structData = uhx.runtime.UReflectionGenerator.getUStruct("$uname")));');
            this.end('}');
            this.newline();
          }

          this.add('private static function mkWrapper():${this.thisConv.haxeType}');
          this.begin(' {');
            this.add('return cast uhx.ue.RuntimeLibraryDynamic.createDynamicWrapperFromStruct(@:privateAccess StaticStruct().wrapped);');
          this.end('}');

          if (ctor == null) {
            this.add('public function new()');
            this.begin(' {');
              this.add('this = mkWrapper();');
              this.newline();
              this.add('var ops = StaticStruct().GetCppStructOps();');
              this.newline();
              this.add('if (!ops.HasZeroConstructor()) ops.Construct(( ( cast this : unreal.VariantPtr).getDynamic() : unreal.Wrapper).getPointer());');
            this.end('}');
          }

          this.newline();
          this.add('@:noCompletion private static var uhx_structData:unreal.UScriptStruct;');
          this.newline();
          this.add('@:noCompletion private inline function get_structData():unreal.UScriptStruct');
          this.begin(' {');
            this.add('return StaticStruct();');
          this.end('}');
        }
      }

      if (c.superClass == null && !isAbstract && !this.thisConv.data.match(CUObject(OInterface,_,_))) {
        this.newline();
        // add constructor
        this.add('private var wrapped:${this.thisConv.haxeGlueType};');
        this.newline();
        if (this.thisConv.haxeGlueType.isReflective()) {
          this.add('private function new(wrapped)');
          this.begin(' {');
            this.add('this.wrapped = wrapped;');
            this.newline();
            this.add('if (Reflect.hasField(Type.getClass(this), "_uhx_isHaxeType"))');
            this.begin(' {');
              this.add('uhx.ClassWrap.pushCtor(this);');
            this.end('}');
          this.end('}');
          // this.add('private function new(wrapped) this.wrapped = wrapped;\n\t');
        } else {
          this.add('private function new(wrapped:${this.thisConv.haxeGlueType.toReflective()}) this.wrapped = wrapped.rawCast();\n\t');
        }

        if (this.thisConv.data.match(CUObject(_))) {
          this.add('private var serialNumber:Int = -1;');
          this.newline();
          this.add('private var internalIndex:Int = -1;');
          this.newline();
          this.add('inline private function invalidate():Void');
          this.begin(' {');
            this.add('this.wrapped = 0;');
          this.end('}');

          this.add('inline public function isValid(checkIfReachable:Bool=false):Bool');
          this.begin(' {');
            // make an inline version that checks if `this` is null as well
            this.add('return this != null && this.pvtIsValid(checkIfReachable);');
          this.end('}');

          this.add('@:noCompletion #if (!cppia && !debug) inline #end private function pvtIsValid(checkIfReachable:Bool):Bool');
          this.begin(' {');
            this.add('return this.wrapped != 0 && '
                +' (!checkIfReachable || uhx.internal.ObjectArrayHelper_Glue.isValid(this.wrapped, internalIndex, serialNumber, false));');
          this.end('}');
        }

      } else if (!c.isInterface && !meta.hasMeta(':global') && !this.thisConv.data.match(CUObject(_))) {
        if (!meta.hasMeta(':noCopy')) {
          var doc = "\n    Invokes the copy constructor of the referenced C++ class.\n    " +
            "This has some limitations - it won't copy the full inheritance chain of the class if it wasn't typed as the exact class\n    " +
            "it will also be a compilation error if the wrapped class forbids the C++ copy constructor;\n    " +
            "in this case, the extern class definition should contain the `@:noCopy` metadata\n  ";
          // copy constructor
          // TODO add params if type has type parameter
          methods.push({
            name: 'copyNew',
            uname: '.copy',
            doc: doc,
            meta:null,
            args:[],
            ret:this.thisConv.withModifiers([Ptr], new TypeRef(['unreal'], 'POwnedPtr', [this.thisConv.haxeType])),
            flags: MNone,
            pos: c.pos,
          });
          methods.push({
            name: 'copy',
            uname: '.copyStruct',
            doc: doc,
            meta:null,
            args:[],
            ret:this.thisConv,
            flags: MNone,
            pos: c.pos,
          });
          var doc = '\n    Assigns the value of `val` to this structure';
          methods.push({
            name: 'assign',
            uname: '.assign',
            doc: doc,
            meta:null,
            args:[{name:'val', t:this.thisConv, opt:null}],
            ret:TypeConv.get(Context.getType("Void"), c.pos),
            flags: MNone,
            pos: c.pos
          });
        } else if (meta.hasMeta(':ustruct') && !Context.defined('UHX_NO_UOBJECT')) {
          this.add('public function copy():${this.thisConv.haxeType.toString()}');
          this.begin(' {');
              this.add('var ret = mkWrapper();');
              this.newline();
              this.add('var ops = StaticStruct().GetCppStructOps();');
              this.newline();
              this.add('if (!ops.HasCopy()) throw "Cannot copy ${this.thisConv.haxeType}";');
              this.newline();
              this.add('if (!ops.HasZeroConstructor()) ops.Construct(( ( cast ret : unreal.VariantPtr).getDynamic() : unreal.Wrapper).getPointer());');
              this.newline();
              this.add('ops.Copy(( ( cast ret : unreal.VariantPtr).getDynamic() : unreal.Wrapper).getPointer(), uhx.internal.HaxeHelpers.getUnderlyingPointer(cast this), 1);');
              this.newline();
              this.add('return ret;');
          this.end('}');
          this.add('@:deprecated("This type does not support copyNew constructors") private function copyNew():unreal.POwnedPtr<${this.thisConv.haxeType.toString()}>');
          this.begin(' {');
            this.add('return throw "The type ${this.thisConv.haxeType} does not support copy constructors";');
          this.end('}');
        } else {
          this.add('@:deprecated("This type does not support copy constructors") private function copy():${this.thisConv.haxeType.toString()}');
          this.begin(' {');
            this.add('return throw "The type ${this.thisConv.haxeType} does not support copy constructors";');
          this.end('}');
          this.add('@:deprecated("This type does not support copy constructors") private function copyNew():unreal.POwnedPtr<${this.thisConv.haxeType.toString()}>');
          this.begin(' {');
            this.add('return throw "The type ${this.thisConv.haxeType} does not support copy constructors";');
          this.end('}');
        }
        if (!meta.hasMeta(':noEquals')) {
            methods.push({
            name: 'equals',
            uname: '.equals',
            doc: null,
            meta:null,
            args:[{name:"other", t:this.thisConv, opt:null}],
            ret:TypeConv.get(Context.getType("Bool"), c.pos),
            flags: MNone,
            pos: c.pos,
          });
        }
        /*
        // add setFinalizer for debugging purposes
        this.newline();
        this.begin('override private function setFinalizer() {');
        this.add('ClassMap.registerWrapper(this.wrapped.ptr.getPointer(), uhx.internal.HaxeHelpers.dynamicToPointer(this));');
        this.add('cpp.vm.Gc.setFinalizer((this : unreal.Wrapper), cpp.Callable.fromStaticFunction(disposeUEPointer));');
        this.end( }');
        this.newline();

        this.add('@:void @:unreflective static function disposeUEPointer(wrapper:unreal.Wrapper):Void ');
        this.begin('{');
        this.add('if (!wrapper.disposed)');
        this.begin('{');
        this.add('ClassMap.unregisterWrapper(wrapper.wrapped.ptr.getPointer(), uhx.internal.HaxeHelpers.dynamicToPointer(wrapper));');
        this.add('wrapper.wrapped.destroy();');
        this.end('}');
        this.end('}');
        */
      }

    for (meth in methods) {
      this.processMethodDef(meth, c.isInterface);
    }
    this.add('#end');
    this.newline();
    this.end('}');

    // before defining the class, let's go through all types and see if we have any type parameters that are dependent on
    // our current type parameter specifications
    this.realBuf.add(this.buf);
    this.buf = new CodeFormatter();
  }

  private function processField(field:ClassField, isStatic:Bool, methods:Array<MethodDef>) {
    var uname = switch(MacroHelpers.extractStrings(field.meta, ':uname')[0]) {
      case null:
        field.name;
      case name:
        name;
    };
    var isNoTemplate = field.meta.has(':noTemplate') || this.cls.meta.has(':noTemplate');

    switch(field.kind) {
    case FVar(read,write):
#if bake_externs
      deps.updateDeps(this.module, field.type);
#end
      this.addDoc(field.doc);
      var meta = field.meta.get();
      this.addMeta(meta);
      if (field.isPublic) {
        this.add('public ');
      } else {
        this.add('private ');
      }

      if (isStatic) {
        this.add('static ');
      }
      var tconv = TypeConv.get( field.type, field.pos, null, isNoTemplate );
      this.add('var ');
      this.add(field.name);
      this.add('(');
      var flags = Property;
      if (isNoTemplate) {
        flags |= NoTemplate;
      }
      var realTConv = if (tconv.data.match(CStruct(_)) && (tconv.modifiers == null || (!tconv.modifiers.has(Ref) && !tconv.modifiers.has(Ptr)))) {
        flags = StructProperty;
        tconv.withModifiers([Ptr]);
      } else {
        tconv;
      }
      if (!field.isPublic) {
        flags |= CppPrivate;
      }
      if (isStatic) {
        flags |= Static;
      }
      if (field.meta.has(":uproperty") && (cls.meta.has(':uclass') || cls.meta.has(':ustruct'))) {
        flags |= UnrealReflective;
      }
      switch(read) {
      case AccNormal | AccCall:
        if (field.meta.has(':expr')) {
          this.add(read == AccCall ? 'get,' : 'default,');
        } else {
          methods.push({
            name: 'get_' + field.name,
            uname: uname,
            args: [],
            ret: realTConv,
            flags: Final | HaxePrivate | flags,
            meta: meta,
            pos: field.pos,
          });
          this.add('get,');
        }
      case _:
        this.add('never,');
      }
      switch(write) {
      case AccNormal | AccCall:
        if (field.meta.has(':expr')) {
          this.add(read == AccCall ? 'set):' : 'default):');
        } else {
          methods.push({
            name: 'set_' + field.name,
            uname: uname,
            args: [{ name: 'value', t: tconv, opt:null }],
            ret: tconv,
            flags: Final | HaxePrivate | flags,
            meta: meta,
            pos: field.pos,
          });
          this.add('set):');
        }
      case AccNever:
        this.add('never):');
      case _:
        if (field.meta.has(':expr')) {
          this.add('null):');
        } else {
          this.add('never):');
        }
      }
      this.add(realTConv.haxeType);
      if (field.meta.has(':expr') && write != AccNever) {
        var expr = field.meta.extract(':expr')[0].params[0];
        this.add(' = ');
        this.add(expr.toString());
      }
      this.add(';');
      this.newline();
    case FMethod(k):
      switch(Context.follow(field.type)) {
      case TFun(args,ret) if (field.meta.has(':expr')):
        this.addDoc(field.doc);
        this.addMeta(field.meta.get().filter(function(meta) return meta.name != ':expr'));
        if (isStatic && field.name != 'new') {
          this.buf.add('static ');
        }
        this.buf.add( field.isPublic ? 'public function ' : 'private function ' );
        this.buf.add(field.name);
        if (field.params.length > 0) {
          this.buf.add('<');
          this.buf.mapJoin(field.params, function(p) return p.name);
          this.buf.add('>');
        }

        inline function typeToString(t:Type) {
          try {
            // this will correctly deal with type params and types that were defined in modules
            return TypeRef.fromType(t, field.pos).toString();
          } catch(e:Dynamic) {
            // unsupported type - like function types
            return t.toString();
          }
        }

        this.buf.add('(');
        this.buf.mapJoin(args, function(arg) return (arg.opt ? '?' : '') + arg.name + ' : ' + typeToString(arg.t));
        this.buf.add(') : ');
        this.buf.add(typeToString(ret));
        var expr = field.meta.extract(':expr')[0].params[0];
        this.buf.add({ expr:EBlock([expr]), pos:expr.pos }.toString());
        this.newline();
      case TFun(args,ret):
#if bake_externs
        for (arg in args) {
          if (arg.name != 'this') {
            deps.updateDeps(this.module, arg.t);
          }
        }
        deps.updateDeps(this.module, ret);
#end
        var cur = null;
        var args = args;
        var flags = MNone;
        if (!field.isPublic) {
          flags |= HaxePrivate | CppPrivate;
        }
        if (isStatic) {
          flags |= Static;
        }
        if (field.meta.has(":ufunction") && cls.meta.has(':uclass')) {
          flags |= UnrealReflective;
        }
        if (isNoTemplate) {
          flags |= NoTemplate;
        }
        var opt = optionals[field.name],
            i = 0;
        inline function getOpt() {
          if (opt == null) {
            return null;
          } else {
            var thisOpt = opt[i++];
            switch(thisOpt.expr) {
            case EConst(CIdent("__empty__")):
              return null;
            case _:
              return thisOpt;
            }
          }
        }

        methods.push( cur = {
          name: field.name,
          uname: uname,
          doc: field.doc,
          meta: field.meta.get(),
          params: [ for (p in field.params) { name:p.name, t:TypeConv.get(p.t, field.pos, null, isNoTemplate) } ],
          args: [ for (arg in args) { name: arg.name, t: TypeConv.get(arg.t, field.pos, null, isNoTemplate), opt:getOpt() } ],
          ret: TypeConv.get(ret, field.pos, false, isNoTemplate),
          flags: flags,
          pos: field.pos,
        });
        if (uname == 'new' && field.name != 'new') {
          // make sure that the return type is of type POwnedPtr
          var realT = getOwnedPtr(ret);
          if (realT == null) {
            Context.warning(
              'The function constructor `${field.name}` should return an `unreal.POwnedPtr` type. Otherwise, this reference will leak', field.pos);
            hadErrors = true;
            realT = ret;
          }
          inline function cancelParams(t:Type) {
            return ret.applyTypeParameters(field.params, [for (p in field.params) Context.typeof(macro null)]);
          }

          var retComplex = cancelParams(ret).toComplexType();
          var thisType = thisConv.haxeType.withParams([ for (p in thisConv.haxeType.params) new TypeRef('Dynamic') ]).toComplexType();
          // make sure that the type is exactly POwnedPtr<MyRetType>
          Context.typeof(macro @:pos(field.pos) {
            var complex:$retComplex = null;
            var x:unreal.POwnedPtr<$thisType> = complex;
          });
        }
      case _: throw 'assert';
      }
    }
  }

  public function processMethodDef(meth:MethodDef, isInterface:Bool) {
    var gm = new GlueMethod(meth, this.type, this.glueType, this.params != null && this.params.length > 0);
    if (isInterface) {
      gm.haxeCode = null;
      gm.headerCode = null;
      gm.ueHeaderCode = null;
      gm.cppCode = null;
    }
    gm.getFieldString( this.buf, this.glue );
  }

  private static function getOwnedPtr(type:Type):Null<Type> {
    while (type != null) {
      switch(type) {
      case TAbstract(aRef, tl):
        if (aRef.toString() == 'unreal.POwnedPtr') {
          return tl[0];
        }
        var a = aRef.get();
        if (a.meta.has(':coreType'))
            break;
#if (haxe_ver >= 3.3)
        // this is more robust than the 3.2 version, since it will also correctly
        // follow @:multiType abstracts
        type = type.followWithAbstracts(true);
#else
        type = a.type.applyTypeParameters(a.params, tl);
#end
      case TInst(_,_) | TEnum(_,_) | TAnonymous(_) | TFun(_,_) | TDynamic(_):
        break;
      case TMono(ref):
        type = ref.get();
      case TLazy(fn):
        type = fn();
      case TType(_,_):
        type = Context.follow(type, true);
      }
    }
    return null;
  }

  private static function escapeName(name:String) {
    return switch(name) {
      case 'this':
        'self';
      case _:
        name;
    };
  }

  private static function escapeString(str:String, buf:CodeFormatter):Void {
    buf << new Escaped(str);
  }

  private function processEnum(e:EnumType) {
    this.pos = e.pos;
    if (!e.isExtern) return;
    if (!e.meta.has(':uextern')) {
      e.meta.add(':uextern', [], e.pos);
    }
    this.typeRef = TypeRef.fromBaseType(e, e.pos);
    this.glueType = this.typeRef.getGlueHelperType();

    this.addDoc(e.doc);
    this.addMeta(e.meta.get());
    if (e.isPrivate)
      this.add('private ');
    this.add('enum ${e.name} ');
    this.begin('{');
      for (name in e.names) {
        var ctor = e.constructs[name];
        switch (Context.follow(ctor.type)) {
        case TEnum(_,_):
        case _:
          throw new Error('Unreal Type Bake: Enum constructor $name has parameters', ctor.pos);
        }
        this.addDoc(ctor.doc);
        this.addMeta(ctor.meta.get());
        this.add(name + ';');
        this.newline();
      }
    this.end('}');
    this.newline();

    var ueName = MacroHelpers.extractStrings(e.meta, ':uname')[0];
    var isClass = e.meta.has(':class');
    var uePack = null;
    if (ueName == null) {
      ueName = e.name;
      uePack = e.pack;
    } else {
      uePack = ueName.split('.');
      ueName = uePack.pop();
    }
    var ueEnumType = uePack.join('::') + (uePack.length == 0 ? '' : '::') + ueName;

    this.add('@:ueGluePath("${this.glueType.getClassPath()}")\n');
    this.addMeta(e.meta.get());
    this.add('@:glueCppIncludes("uhx/expose/HxcppRuntime.h", "uhx/EnumGlue.h")');
    this.newline();
    var fmt = new CodeFormatter();
    fmt << '@:ueCppDef("';
    var data = new HelperBuf();
    data << 'namespace uhx {\n\n';
    data << 'template<> struct EnumGlue<$ueEnumType> {\n'
      << '\tstatic $ueEnumType haxeToUe(unreal::UIntPtr haxe);\n'
      << '\tstatic unreal::UIntPtr ueToHaxe($ueEnumType ue);\n'
      << '};\n';
    data << '}\n\n';
    data << '$ueEnumType uhx::EnumGlue< $ueEnumType >::haxeToUe(unreal::UIntPtr haxe) {\n'
          << '\t\treturn ($ueEnumType) ${glueType.getCppClass()}::haxeToUe( uhx::expose::HxcppRuntime::enumIndex(haxe) + 1 );\n}\n'
        << 'unreal::UIntPtr uhx::EnumGlue< $ueEnumType >::ueToHaxe($ueEnumType ue) {\n'
          << '\t\tstatic unreal::UIntPtr array = uhx::expose::HxcppRuntime::getEnumArray("$ueEnumType");\n'
          << '\t\treturn uhx::expose::HxcppRuntime::arrayIndex(array, ${glueType.getCppClass()}::ueToHaxe((int) ue) - 1);\n}';
    fmt.addEscaped(data.toString());
    fmt << '")';
    this.add(fmt);
    this.newline();
    this.add('@:ifFeature("${typeRef.getClassPath(true)}.*") ');
    this.add('class ${e.name}_EnumConv ');
    this.begin('{');
      this.add('public static var all:Array<${e.name}>;');
      this.newline();
      this.add('static function __init__()');
      this.begin('{');
        this.add('uhx.EnumMap.set("$ueEnumType", all = std.Type.allEnums(${this.typeRef}));');
        this.newline();
        this.add('uhx.EnumMap.setUeToHaxe("$ueEnumType", ueToHaxe);');
        this.newline();
        this.add('uhx.EnumMap.setHaxeToUe("${typeRef.getClassPath(true)}", haxeToUe);');
      this.end('}');
      this.newline();
      var ueCall = isClass ?
        uePack.join('::') + (uePack.length == 0 ? '' : '::') + ueName :
        uePack.join('::');
      if (ueCall != '')
        ueCall = ueCall + '::';

      var ueToHaxe = new HelperBuf() + 'switch(($ueEnumType) value) {\n\t',
          haxeToUe = new HelperBuf() + 'switch(value) {\n\t';
      var idx = 1;
      for (name in e.names) {
        var ctor = e.constructs[name];
        var ueName = MacroHelpers.extractStrings(ctor.meta, ':uname')[0];
        if (ueName == null) ueName = name;
        ueToHaxe += 'case $ueCall$ueName:\n\t\treturn $idx;\n\t';
        haxeToUe += 'case $idx:\n\t\treturn (int) $ueCall$ueName;\n\t';
        idx++;
      }
      ueToHaxe += '}\n\treturn 0;';
      haxeToUe += '}\n\treturn 0;';

      this.glue.add('public static function ueToHaxe(value:Int):Int;\n');
      this.add('@:glueHeaderCode("static int ueToHaxe(int value);")');
      this.newline();
      this.add('@:glueCppCode("int ${this.glueType.getCppType()}_obj::ueToHaxe(int value) {');
      escapeString('\n\t' +ueToHaxe.toString() + '\n}', this.buf);
      this.add('")');
      this.newline();
      this.add('@:ifFeature("${typeRef.getClassPath(true)}.*") ');
      this.add('public static function ueToHaxe(value:Int):Int');
      this.begin(' {');
        this.add('return ${this.glueType}.ueToHaxe(value);');
      this.end('}');

      this.glue.add('public static function haxeToUe(value:Int):Int;\n');
      this.add('@:glueHeaderCode("static int haxeToUe(int value);")');
      this.newline();
      this.add('@:glueCppCode("int ${this.glueType.getCppType()}_obj::haxeToUe(int value) {');
      escapeString('\n\t' +haxeToUe.toString() + '\n}', this.buf);
      this.add('")');
      this.newline();
      this.add('@:ifFeature("${typeRef.getClassPath(true)}.*") ');
      this.add('public static function haxeToUe(value:Int):Int');
      this.begin(' {');
        this.add('return ${this.glueType}.haxeToUe(value);');
      this.end('}');

      this.add('public static inline function wrap(v:Int):${this.typeRef} return all[ueToHaxe(v) - 1];');
      this.newline();
      this.add('public static inline function unwrap(v:${this.typeRef}):Int return haxeToUe(v.getIndex() + 1);');
    this.end('}');
    this.newline();

    this.realBuf.add(this.buf);
    this.buf = new CodeFormatter();
  }

  private function addMeta(metas:Metadata) {
    if (metas != null) {
      for (meta in metas) {
        if (meta.name == ':build') {
          continue;
        }
        #if UHX_NO_UOBJECT
        if (meta.name == ':glueCppIncludes' && meta.params != null)
        {
          meta.params = meta.params.filter(function(param) {
            return param.toString().toLowerCase().indexOf('noexporttypes.h') < 0;
          });
        }
        #end
        this.add('@' + meta.name);
        if (meta.params != null && meta.params.length > 0) {
          this.add('(');
          var first = true;
          for (param in meta.params) {
            if (first) first = false; else this.add(', ');
            this.add(param.toString());
          }
          this.add(')');
        }
        if (meta.name == ':final')
          this.add(' @:nonVirtual ');
        this.newline();
      }
    }
  }

  inline private function addDoc(doc:Null<String>) {
    if (doc != null) {
      buf << new Comment(doc);
    }
  }

  inline private function begin(?brkt:String) {
    buf << new Begin(brkt);
  }

  inline private function end(?brkt:String) {
    buf << new End(brkt);
  }

  inline private function newline() {
    buf << new Newline();
  }

  inline private function add(dyn:Dynamic) {
    buf << Std.string(dyn);
  }

  private function get_voidType():TypeConv {
    if (this.voidType == null)
      this.voidType = TypeConv.get(Context.getType('Void'), this.pos);
    return this.voidType;
  }

  private static function getModule(name:String, pos:Position) {
    try {
      return Context.getModule(name);
    } catch(e:Dynamic) {
      if (!Std.string(e).startsWith("Type not found : " + name)) {
        throw new Error(Std.string(e), pos);
      }
      return null;
    }
  }
}

typedef GeneratedInfo = {
  ver:Int,
  srcFile:String
}
